> **Abschlussarbeit** **(Master)** **im** **Bereich**
> **Plattform-Engineering**

**Arbeitstitel** **(Deutsch)**

Analyse und Konzeption einer Internen Entwicklerplattform (IDP) zur
Verbesserung der Developer Experience im Kontext moderner
Plattform-Engineering-AnsÃ¤tze mit prototypischer Validierung

**Title** **(English)**

Analysis and Design of an Internal DeveloperPlatform (IDP) to
EnhanceDeveloperExperience within Modern Platform Engineering Approaches
with Prototypical Validation

**Motivation**

Die zunehmende Verbreitung verteilter Softwarearchitekturen,
insbesondere Microservices, Cloud-native Technologien und
Continuous-Delivery-Praktiken, fÃ¼hrt zu einer signifikanten Steigerung
der KomplexitÃ¤t moderner Softwareentwicklung. Entwicklerinnen und
Entwickler sind dabei nicht mehr ausschlieÃŸlich mit der Implementierung
fachlicher Anforderungen konfrontiert, sondern zunehmend auch mit
infrastrukturellen, betrieblichen und sicherheitsrelevanten
Fragestellungen. Diese Entwicklung erhÃ¶ht die kognitive Belastung der
Entwicklungsteams und kann sich negativ auf ProduktivitÃ¤t,
SoftwarequalitÃ¤t sowie die wahrgenommene Arbeitszufriedenheit auswirken.

Vor diesem Hintergrund hat sich Plattform-Engineering als ein
vielversprechender Ansatz etabliert, um Entwicklungs- und
Betriebsaspekte systematisch zu abstrahieren und standardisieren.
Zentrales Artefakt dieses Ansatzes ist die InterneEntwicklerplattform
(Internal Developer Plattform, IDP), die als vermittelnde Schicht
zwischen Entwicklungsteams und der zugrunde liegenden Infrastruktur
fungiert. Ziel einer solchen Plattform ist es, wiederverwendbare,
sichere und standardisierte Self-Service-FunktionalitÃ¤ten
bereitzustellen und damit die Developer Experience (DX) nachhaltig zu
verbessern.

Trotz der wachsenden Bedeutung von Plattform-Engineering in der
industriellen Praxis besteht weiterhin ein erheblicher Forschungsbedarf.
Insbesondere fehlen fundierte Analysen zu Gestaltungsprinzipien,
Architekturentscheidungen und organisatorischen Rahmenbedingungen, die
den erfolgreichen Einsatz interner Entwicklerplattformen begÃ¼nstigen.
Ebenso ist bislang unzureichend untersucht, wie sich Standardisierung,
Governance und Sicherheit mit der notwendigen FlexibilitÃ¤t fÃ¼r
unterschiedliche Entwicklerteams vereinbaren lassen.

DieseMasterarbeit adressiert dieseForschungslÃ¼cke, indem sie
Plattform-Engineering-AnsÃ¤tze systematisch analysiert und auf ihre
Eignung zur Verbesserung der Developer Experience im Kontext interner
Entwicklerplattformen untersucht.

**Kurzbeschreibung**

Ziel dieser Masterarbeit ist die **wissenschaftlich** **fundierte**
**Analyse** **und** **Konzeption** einer Internen Entwicklerplattform
(Internal Developer Platform, IDP) unter Anwendung moderner
Plattform-Engineering-Prinzipien. Der Schwerpunkt der Arbeit liegt auf
der Untersuchung des Einflusses solcher Plattformen auf die Developer
Experience sowie auf der Identifikation zentraler Erfolgsfaktoren fÃ¼r
deren Gestaltung und EinfÃ¼hrung.

Zu Beginn erfolgt eine umfassende Analyse des aktuellen Forschungsstands
sowie relevanter industrieller Best Practices im Bereich
Plattform-Engineering und Developer Experience. Auf dieser Basis werden
zentrale Konzepte, Architekturmuster und Designprinzipien systematisch
eingeordnet und kritisch bewertet. Ein besonderer Fokus liegt dabei auf
der Frage, wie interne Entwicklerplattformen gestaltet werden mÃ¼ssen, um
sowohl teamspezifischeAnforderungen zu berÃ¼cksichtigen als auch
unternehmensweite Standards in Bezug auf Sicherheit, Compliance und
Wartbarkeit sicherzustellen.

Darauf aufbauend wird ein konzeptionelles Zielbild einer internen
Entwicklerplattform entwickelt. Dieses umfasst unter anderem eine
Ã¼bergeordnete Architektur, zentrale Plattformkomponenten sowie
Mechanismen zur Integration bestehender Entwicklungs- und
Betriebswerkzeuge. ErgÃ¤nzend werden Metriken und qualitative Kriterien
zur Bewertung der Developer Experience hergeleitet, um die Wirkung der
Plattform strukturiert analysieren zu kÃ¶nnen.

Zur **Validierung** **der** **konzeptionellen** **Ergebnisse** wird
abschlieÃŸend ein prototypischer Plattformansatz in Form eines Minimal
Viable Products (MVP) entworfen. Diese prototypische Umsetzung dient
ausschlieÃŸlich der exemplarischen Veranschaulichung und Bewertung
zentraler Konzepte und erhebt keinen Anspruch auf produktiven Einsatz.
Die Implementierung steht somit nicht im Vordergrund, sondern fungiert
als experimentelles Artefakt zur UnterstÃ¼tzung der Forschungsziele.

Die Arbeit schlieÃŸt mit einer kritischen Reflexion der Ergebnisse sowie
einer Diskussion ihrer Ãœbertragbarkeit auf reale Organisations- und
Entwicklungskontexte. Damit leistet die Masterarbeit einen Beitrag zur
wissenschaftlichen Auseinandersetzung mit Plattform-Engineering und
Developer Experience und liefert zugleich konzeptionelle Orientierung
fÃ¼r zukÃ¼nftige Forschung und Praxis.

**Voici** **le** **thÃ¨me** **gÃ©nÃ©ral** **sur** **lequel** **travaille**
**toute** **l'Ã©quipe.** **Juste** **pour** **complÃ©ter** **le**
**sujet.** **Mon** **travail** **doit** **donc** **Ãªtre** **une**
**illustration** **et** **une** **Ã©tude** **scientifique** **de**
**tout** **ce** **qu'ils** **font.**

**Beschreibung**

Als DevOps Engineer beabsichtige ich, Methoden des Platform Engineering
sowie deren Einfluss auf die Developer Experience zu untersuchen, um die
Entwicklung einer skalierbaren, sicheren und benutzerfreundlichen
Internen Entwicklerplattform (Internal Developer Platform, IDP) zu
unterstÃ¼tzen. Ziel ist es, Architekturen, Technologien und
Integrationsstrategien zu evaluieren, die die Anforderungen von
Entwicklungsteams erfÃ¼llen und gleichzeitig Konsistenz sowie Compliance
gewÃ¤hrleisten.

Durch die Implementierung eines Self-Service-Minimum-Viable-Products
(MVP) sollen Entwicklerinnen und Entwickler befÃ¤higt werden, Deployments
eigenstÃ¤ndig durchzufÃ¼hren, wobei Leitplanken definiert werden, die
Sicherheit und RichtlinienkonformitÃ¤t sicherstellen. DarÃ¼ber hinaus
sollen Motivationsstrategien identifiziert werden, um die Akzeptanz der
Plattform zu fÃ¶rdern und sicherzustellen, dass sich diese mit
zukÃ¼nftigen Technologien wie Cloud-Native-Architekturen und
Microservices weiterentwickelt. Diese Initiative zielt darauf ab,
Entwicklungsworkflows zu optimieren, den operativen Aufwand zu
reduzieren und die Zufriedenheit der Entwickler zu verbessern.

**Wirtschaftlicher** **Nutzen** **(Business** **Value)**

> â€¢ Beschleunigt die Time-to-Market fÃ¼r Serviceanfragen und reduziert
> repetitive TÃ¤tigkeiten
>
> â€¢ Reduziert die operative und kognitive Belastung von Entwicklerinnen
> und Entwicklern â€¢ Stellt Compliance und Sicherheit durch
> standardisierte Workflows sicher
>
> â€¢ Verbessert das Engagement und die Bindung von Entwicklerinnen und
> Entwicklern
>
> â€¢ Macht die Infrastruktur zukunftssicher im Hinblick auf sich
> wandelnde technologische Landschaften
>
> â€¢ Reduziert die operative und kognitive Belastung von Entwicklerinnen
> und Entwicklern â€¢ Stellt Compliance und Sicherheit durch
> standardisierte Workflows sicher
>
> â€¢ Verbessert das Engagement und die Bindung von Entwicklerinnen und
> Entwicklern
>
> â€¢ Macht die Infrastruktur zukunftssicher im Hinblick auf sich
> wandelnde technologische Landschaften

**Ziele**

> â€¢ Untersuchung von Plattform-Engineering-Methoden und deren
> Auswirkungen auf die Developer Experience (DX)
>
> â€¢ Analyse erfolgreicher Implementierungsstrategien fÃ¼r Interne
> Entwicklerplattformen
>
> â€¢ Bewertung von Mechanismen zur UnterstÃ¼tzung teamspezifischer
> Anforderungen innerhalb einer einheitlichen Architektur
>
> â€¢ Untersuchung geeigneter Architekturen und Technologien fÃ¼r
> skalierbare Interne Entwicklerplattformen
>
> â€¢ Implementierung eines sicheren, richtlinienkonformen
> Self-Service-MVPs
>
> â€¢ Integration und Orchestrierung von Werkzeugen und Services innerhalb
> der IDP
>
> â€¢ Identifikation von Strategien zur Motivation und BefÃ¤higung der
> Entwickler zur Nutzung der Plattform
>
> â€¢ Sicherstellung der AnpassungsfÃ¤higkeit der IDP an zukÃ¼nftige
> Technologien und Anforderungen

**Ausrichtung** **zwischen** **KX** **Infrastructure** **und** **CI/CD**

> â€¢ DurchfÃ¼hrung von Experteninterviews innerhalb des DevOps-Teams sowie
> darÃ¼ber hinaus
>
> â€¢ Definition der Developer Experience und Ableitung entsprechender Key
> Performance Indicators (KPIs)
>
> â€¢ Gap-Analyse zwischen dem aktuellen Status quo und dem angestrebten
> Zielbild â€¢ Ableitung eines Ã¼bergeordneten architektonischen
> Gesamtbildes
>
> â€¢ Implementierung eines MVPs mit mindestens einem Anwendungsfall
>
> â€¢ Erstellung einer Roadmap sowie von Empfehlungen zur Implementierung
> einer Internen Entwicklerplattform

KX = Kubernetes Experience / Knowledge Experience / Developer Experience
(interne)
=================================================

Ja â€“ ich kann dir **einen konkreten, nachvollziehbaren Prototypen** ausarbeiten, der **direkt als Kapitel 6** in einer wissenschaftlichen Arbeit verwendet werden kann.
Ich zeige dir **(1) eine visuelle Architektur**, **(2) konkrete Artefakte (Templates, Repos, Pipelines)** und **(3) eine evaluierbare End-to-End-Ablaufbeschreibung**.
Alles ist **minimal, lauffÃ¤hig und realistisch**, aber bewusst **nicht produktiv**.

---

## 6. Prototypischer Plattformansatz und Evaluation

### 6.2 Beschreibung des prototypischen Plattformansatzes

**Referenz-Stack:** Backstage + Argo CD auf Kubernetes

---

## 6.2.1 Prototyp-Architektur (konkret)

![Image](https://devops.com/wp-content/uploads/2023/08/Mckinsey-Co-platform-reference-architecture.png)

![Image](https://argo-cd.readthedocs.io/en/release-2.3/assets/argocd_architecture.png)

![Image](https://learn.microsoft.com/en-us/azure/architecture/example-scenario/gitops-aks/media/gitops-flux.svg)

![Image](https://developers.redhat.com/sites/default/files/gocb_0104.png)

### ArchitekturÃ¼bersicht (logische Ebene)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Developer                                  â”‚
â”‚                                            â”‚
â”‚  Backstage Developer Portal                â”‚
â”‚  - Service Catalog                         â”‚
â”‚  - Scaffolder (Golden Path)                â”‚
â”‚  - TechDocs                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚ 1. Create Service
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Service Repository (Git)                   â”‚
â”‚ - App Code                                 â”‚
â”‚ - Dockerfile                               â”‚
â”‚ - Kubernetes Manifests                     â”‚
â”‚ - CI Pipeline                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚ 2. CI (Build/Test/Scan)
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Container Registry                         â”‚
â”‚ - Versioned Images                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚ 3. GitOps Update
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Environment Repository (GitOps)            â”‚
â”‚ - desired state (dev/test)                 â”‚
â”‚ - Image Tags/Digests                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚ 4. Sync
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Argo CD                                    â”‚
â”‚ - Policy Checks                            â”‚
â”‚ - Sync to Cluster                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Kubernetes Test Namespace                  â”‚
â”‚ - Deployed Service                         â”‚
â”‚ - Observability Basics                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 6.2.2 Konkrete Artefakte des Prototyps

### A) Backstage â€“ Developer Portal

**Implementierte Funktionen**

| Funktion        | Konkrete Umsetzung                |
| --------------- | --------------------------------- |
| Service Catalog | `Component`, `System`, `API` YAML |
| Scaffolder      | Template â€hello-serviceâ€œ          |
| TechDocs        | Markdown + mkdocs                 |
| Ownership       | `spec.owner` je Service           |

#### Beispiel: Catalog-Entity (Component)

```yaml
apiVersion: backstage.io/v1alpha1
kind: Component
metadata:
  name: hello-service
  description: Beispielservice der IDP
spec:
  type: service
  lifecycle: experimental
  owner: team-platform
  system: demo-system
```

---

### B) Golden Path â€“ Scaffolder Template

![Image](https://backstage.io/assets/images/backstage-front-back-arch-b29f4066894034907e55d41b18444821.jpeg)

![Image](https://developers.redhat.com/sites/default/files/screenshot_2025-06-13_at_12.02.34.png)

![Image](https://cdn.prod.website-files.com/622b2fcc29fc56492b771cb8/65cb50dc87d945f9e162f217_M5mSTFf3R6YIQgRII-bpS01CoZtRZaD04EwcVwAa4tXIwdmYYTsN43Dwc1II7E8E0-G94jdYeLOBcZJp6AsF3ZYGBljQ54RXBM94_U7ytzNdTEc_niNbh9KaWdDrff6Xv7n2H2law7SSALMFcTOmHsQ.png)

**Was erzeugt der Template konkret?**

```
hello-service/
â”œâ”€ src/
â”‚  â””â”€ main.py
â”œâ”€ Dockerfile
â”œâ”€ k8s/
â”‚  â”œâ”€ deployment.yaml
â”‚  â”œâ”€ service.yaml
â”‚  â””â”€ ingress.yaml
â”œâ”€ .github/workflows/ci.yaml
â”œâ”€ catalog-info.yaml
â”œâ”€ mkdocs.yml
â””â”€ README.md
```

â¡ **Wichtig:** Entwickler mÃ¼ssen **keine Plattformdetails kennen**.

---

### C) Beispiel-Service (Minimal)

```python
from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello from IDP Prototype"

app.run(host="0.0.0.0", port=8080)
```

---

### D) CI-Pipeline (Governance by Design)

```yaml
jobs:
  build:
    steps:
      - docker build
      - docker push

  test:
    steps:
      - unit tests

  security:
    steps:
      - image scan
      - kube-lint

  gate:
    if: failure -> block merge
```

**Guardrails**

âœ” Ressourcenlimits verpflichtend
âœ” Keine privilegierten Container
âœ” Labels (`app`, `team`, `env`) erforderlich

---

### E) GitOps-Repository (Environment)

```yaml
apiVersion: apps/v1
kind: Deployment
spec:
  template:
    spec:
      containers:
      - image: registry/hello-service:1.0.0
```

â¡ **Keine direkte Cluster-Ã„nderung** durch Entwickler
â¡ **Nachvollziehbarkeit & Rollback** jederzeit mÃ¶glich

---

## 6.3 End-to-End-Golden-Path (konkret)

![Image](https://microsoft.github.io/code-with-engineering-playbook/CI-CD/gitops/images/GitopsWorflowVsTraditionalPush.jpg)

![Image](https://jellyfish.co/wp-content/uploads/2025/12/Developer-Productivity-Golden-Paths.png)

![Image](https://www.chef.io/images/cheflibraries/blogs/gitops_cicd.png?sfvrsn=d6cee9e4_0)

**Ablauf**

1. Entwickler klickt in Backstage auf **â€Create new serviceâ€œ**
2. Repository + CI + Docs werden automatisch erstellt
3. CI validiert Code, Security & Policies
4. GitOps-Repo wird aktualisiert
5. Argo CD deployed automatisch nach Kubernetes
6. Service ist erreichbar + dokumentiert

â± **Time-to-First-Deployment:** wenige Minuten

---

## 6.4 Evaluation des Prototyps (direkt verwendbar)

### ErfÃ¼llung der Zielkriterien

| Kriterium        | Bewertung               |
| ---------------- | ----------------------- |
| Self-Service     | âœ” vollstÃ¤ndig           |
| Standardisierung | âœ” Golden Path           |
| FlexibilitÃ¤t     | âœ” Templates erweiterbar |
| Governance       | âœ” automatisiert         |
| Transparenz      | âœ” Portal + Git          |
| Skalierbarkeit   | â–³ konzeptionell gegeben |

### Reflexion

Der Prototyp zeigt, dass eine **IDP nicht durch Tool-KomplexitÃ¤t**, sondern durch
â¡ **klare Pfade**,
â¡ **automatisierte Guardrails** und
â¡ **Developer-zentrierte Abstraktion**
wirksam wird.

---

## NÃ¤chster Schritt (optional)

Wenn du mÃ¶chtest, kann ich dir als NÃ¤chstes:

1. ğŸ“ **eine echte Architektur-Grafik (Mermaid / Draw.io)**
2. ğŸ§ª **ein Evaluationskapitel mit Metriken (DX, Lead Time, Cognitive Load)**
3. ğŸ§¾ **eine tabellarische Zuordnung zu Kapitel 5 (Konzept â†” Prototyp)**
4. ğŸ§© **einen vollstÃ¤ndigen Beispiel-Anhang (Templates + YAML)**

sagen dir einfach, **was du fÃ¼r die Abgabe brauchst**.






Ja â€” und danke, das ist eine **wichtige Kurskorrektur**:
Nicht â€IDP fÃ¼r Ticket-Reduktionâ€œ, sondern ein **IDP-Prototyp**, der **dieses DevOps/Dev-Team** widerspiegelt und ihnen hilft, **Self-Service Deployments mit Guardrails** umzusetzen, DX zu messen und Adoption zu fÃ¶rdern.

Ich helfe dir dabei, einen Prototyp zu bauen, der genau diese Erwartungen erfÃ¼llt: **skalierbar, sicher, compliance-fÃ¤hig, developer-freundlich** â€“ und als MVP mit **mindestens einem echten Use Case** funktioniert.

---

# Was der IDP-Prototyp fÃ¼r dieses Team liefern muss

Aus deiner Beschreibung lassen sich die â€Nicht-verhandelbarenâ€œ Anforderungen ableiten:

1. **Self-Service MVP**: Entwickler kÃ¶nnen Deployments selbst auslÃ¶sen
2. **Guardrails**: Sicherheit/Policies sind technisch erzwungen, nicht nur Doku
3. **Tool-Integration**: CI/CD, Repo, Artifact, Secrets, Observability (zumindest angeteasert)
4. **DX-Fokus**: messbare KPIs + Gap-Analyse + Feedback-Loop
5. **Adoption**: Motivations-/Enablement-Strategien und â€Plattform als Produktâ€œ
6. **ZukunftsfÃ¤hig**: Cloud-Native/Microservices ready (nicht komplett bauen, aber kompatibel designen)

---

# Der Prototyp, den wir bauen: â€Golden Path IDPâ€œ (Backstage-basiert)

Statt â€alles fÃ¼r alleâ€œ, baust du einen Prototypen, der ein Team wirklich benutzt:
**Ein Golden Path** fÃ¼r einen Beispielservice, der 80% der RealitÃ¤t abdeckt.

## MVP-Use-Case (empfohlen)

**â€Deploy eines Services in eine Dev/Test-Umgebung mit Guardrailsâ€œ**

Warum der so gut ist:

* zeigt Self-Service,
* zeigt Policies (RBAC, Environments, Approvals),
* zeigt CI/CD-Orchestrierung,
* ist messbar (Lead Time, Failure Rate, Self-Service Quote),
* und skaliert spÃ¤ter auf weitere Services.

---

# Zielarchitektur fÃ¼r euren Prototyp

## 1) Backstage als â€Frontdoorâ€œ

* **Software Catalog**: Services, Teams, Owner, Systemkontext
* **TechDocs**: Runbooks, Golden Path Doku, Standards
* **Scaffolder**: Template â€Create/Deploy Serviceâ€œ (oder nur Deploy)
* **Kubernetes Plugin / CI Plugin** (optional, aber stark fÃ¼rs Demo)

## 2) â€Control Planeâ€œ fÃ¼r Guardrails

Backstage selbst ist nicht die Policy-Engine. Du brauchst eine kleine Schicht dahinter:

* **IDP Orchestrator (kleines Backend)**: nimmt Requests aus Backstage entgegen und triggert CI/CD
* **Policy Engine** (leichtgewichtig im MVP):

  * minimal: Regeln im Orchestrator
  * besser: OPA/Conftest oder Gatekeeper/Kyverno (wenn Kubernetes im Spiel ist)
* **Audit / Logging**: jeder Deploy ist nachvollziehbar

## 3) Execution Plane

* CI/CD (GitHub Actions / GitLab / Azure DevOps)
* Deploy Target (Kubernetes oder alternativ: VM/Container Runtime)
* Secrets (Vault / Cloud Secrets / sealed secrets â€“ MVP kann stubben)

Das klingt nach viel, ist aber als Prototyp schlank machbar, wenn du es richtig zuschneidest.

---

# So sieht der Prototyp im Backstage UI aus (was Entwickler erleben)

### Startseite: â€My Team / My Servicesâ€œ

* Liste der Services aus dem Catalog
* FÃ¼r jeden Service: Owner, Repo, CI Pipeline, Doku, Deploy Status

### â€Golden Pathâ€œ Seite pro Service

Buttons/Actions:

* **Deploy to Dev**
* **Promote to Test** (optional, mit Approval)
* **View Pipeline Run**
* **View Runtime (K8s)**

### Guardrails sichtbar & spÃ¼rbar

* Nur erlaubte Environments
* Nur erlaubte Branches/Tags
* Versionschema muss passen
* Approvals (z. B. Test/Prod)
* Policy violations geben **klare Fehlermeldungen** (DX!)

---

# Schritt-fÃ¼r-Schritt Plan von Null (Prototyp in sinnvollen Sprints)

## Sprint 1 â€” â€Backstage lÃ¤uft + Team/Service spiegelnâ€œ (Fundament)

**Ergebnis:** Portal zeigt euer Team und eure Services so, wie sie wirklich sind.

1. Backstage App erzeugen (Standard Create-App)
2. **Software Catalog** minimal befÃ¼llen:

   * 1â€“2 Teams (Group)
   * 1 System (z. B. â€Paymentsâ€œ)
   * 2â€“3 Services (Component) mit Owner & Repo-Links
3. **TechDocs**: 1 Golden-Path Doku (Wie deployen wir?)
4. KPI-Baseline definieren (auch wenn nur geschÃ¤tzt)

âœ… Demo nach Sprint 1: â€So sieht unser Engineering-Landscape aus.â€œ

---

## Sprint 2 â€” â€Self-Service Deploy Button (ohne harte Policies)â€œ

**Ergebnis:** Entwickler kÃ¶nnen aus Backstage einen Deploy triggern.

1. Scaffolder Template â€Deploy Serviceâ€œ:

   * Service wÃ¤hlen (EntityPicker)
   * Environment (dev/test)
   * Version/Branch
2. Orchestrator-Endpoint (mini API) oder direkter CI Trigger
3. Pipeline startet und liefert Run-URL zurÃ¼ck (Backstage Link)

âœ… Demo nach Sprint 2: â€Deploy per Klick aus der IDP.â€œ

---

## Sprint 3 â€” â€Guardrails echt machen (Policies + RBAC)â€œ

**Ergebnis:** Deploy geht nur, wenn Regeln erfÃ¼llt sind.

Guardrails (MVP-Set, sehr realistisch):

* **RBAC**: nur Team-Owner dÃ¼rfen Service deployen
* **Environment Rules**:

  * Dev: frei
  * Test: nur main branch oder tags
* **Approval** (fÃ¼r Test optional): via Codeowners/PR Check oder Pipeline Approval
* **Policy Checks**:

  * Branch/Tag naming
  * Required metadata (owner, system)
  * Optional: SAST/Dependency Check als required pipeline stage

âœ… Demo nach Sprint 3: â€Plattform verhindert unsichere Deploys.â€œ

---

## Sprint 4 â€” â€DX-Messung + Adoption-Mechanikâ€œ

**Ergebnis:** Du kannst zeigen, dass DX und Overhead messbar besser werden.

DX KPIs (fÃ¼r Prototyp perfekt):

* **Self-Service Quote**: Anteil Deployments via IDP
* **Time to Deploy**: Klick â†’ Running
* **Change Failure Rate**: failed deploys / total
* **MTTR** (wenn du Observability antippst)
* **Cognitive Load Proxy**: #Manueller Steps reduziert (qualitativ + Survey)

Adoption-Mechanik (sehr wichtig):

* Golden Path prominent
* â€Docs at point of needâ€œ (TechDocs direkt im Template verlinkt)
* Erfolg sichtbar machen (Leaderboard/Badges nicht zwingend, aber mÃ¶glich)
* Feedback Button: â€Was hat genervt?â€œ â†’ Issues/Backlog

âœ… Demo nach Sprint 4: â€Wir messen DX und steigern Adoption.â€œ

---

# Der Prototyp spiegelt â€das Team, das die Tickets erstellt hatâ€œ

Was du damit abbildest (realistisch):

* DevOps/Platform Team als Enabler (nicht Gatekeeper)
* Standardisierte Deploy-Workflows
* Ownership im Catalog statt Tribal Knowledge
* Compliance als Code (Policies), nicht als PDF
* Tool-Orchestrierung (CI/CD, Repo, Runtime)
* klare Roadmap: mehr Use-Cases, mehr Automatisierung, mehr Teams

---

# Was ich als NÃ¤chstes konkret fÃ¼r dich liefern kann (ohne dass du dich auskennen musst)

Ich kann dir direkt ausformulieren:

1. **Backstage Prototyp Blueprint (Ordnerstruktur, Plugins, Minimal-Config)**
2. **Golden Path Use-Case detailliert** (Inputs, Outputs, Guardrails, Pipeline-Steps)
3. **Scaffolder Template YAML** fÃ¼r â€Deploy Serviceâ€œ (MVP-tauglich)
4. **Orchestrator API Vertrag** (OpenAPI-Ã¤hnlich, sehr simpel)
5. **DX KPI Dashboard-Konzept** (was loggen, wie messen)

---

## Eine Sache brauche ich trotzdem (aber du kannst auch â€œweiÃŸ nichtâ€ sagen)

FÃ¼r den Deploy-Use-Case: Welche CI/CD-Welt ist bei euch am wahrscheinlichsten im Prototyp?

* Azure DevOps Pipelines
* GitLab CI
* GitHub Actions
* Jenkins
* â€egal, Hauptsache Demoâ€œ




# Architekturdiagramm


Alles klar. **Hier ist die Architektur** fÃ¼r euren **IDP-Prototyp (â€Golden Path: Self-Service Deployments mit Guardrailsâ€œ) â€“ zuerst als ASCII**, danach als **draw.io-Struktur (Swimlanes + Boxen + Pfeile)**.

---

# 1) Architekturdiagramm als ASCII

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                DEVELOPERS                                 â”‚
â”‚   - Backstage UI nutzen (Deploy klicken, Status sehen, Doku lesen)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                             BACKSTAGE (IDP)                               â”‚
â”‚                                                                           â”‚
â”‚  [Portal UI]                     [Core Capabilities]                      â”‚
â”‚  - Home / My Team / My Services   - Software Catalog (Ownership, Service)  â”‚
â”‚  - Golden Path Page              - TechDocs (Golden Path, Runbooks)       â”‚
â”‚  - Templates / Actions           - Scaffolder (Forms, UX, Input Valid.)   â”‚
â”‚                                   - Plugins: CI/CD, K8s, Observability*    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         IDP CONTROL PLANE (Backend)                        â”‚
â”‚                 (kleiner "Orchestrator" hinter Backstage)                 â”‚
â”‚                                                                           â”‚
â”‚  - Request API (Deploy/Promote)                                           â”‚
â”‚  - Guardrails/Policy Checks (RBAC, Env Rules, Naming, Compliance)         â”‚
â”‚  - Audit Log / Event Stream (wer hat was wann deployed?)                 â”‚
â”‚  - Adapter zu CI/CD & Tools (entkoppelt Backstage von Tool-Details)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚                           â”‚                           â”‚
              â”‚                           â”‚                           â”‚
              â–¼                           â–¼                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  IDENTITY / ACCESS     â”‚     â”‚        CI/CD             â”‚   â”‚  GOVERNANCE / AUDIT  â”‚
â”‚  (SSO/RBAC)            â”‚     â”‚ (ADO / GitLab / GH / ...)â”‚   â”‚  - Logs/Reports      â”‚
â”‚  - AuthN/AuthZ         â”‚     â”‚ - Pipeline Trigger       â”‚   â”‚  - KPI Metrics       â”‚
â”‚  - Team/Role mapping   â”‚     â”‚ - Required Checks        â”‚   â”‚  - Compliance Proof  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                                â”‚                          â”‚
            â”‚                                â–¼                          â”‚
            â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
            â”‚                    â”‚     ARTIFACTS / SBOM      â”‚           â”‚
            â”‚                    â”‚  - Container Registry     â”‚           â”‚
            â”‚                    â”‚  - Dependency Scans*      â”‚           â”‚
            â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
            â”‚                                 â”‚                         â”‚
            â–¼                                 â–¼                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          EXECUTION PLANE (RUNTIME)                         â”‚
â”‚                                                                           â”‚
â”‚  - Kubernetes (Dev/Test)  OR  VM/Container Platform                        â”‚
â”‚  - Policy Enforcement at runtime: Gatekeeper/Kyverno*                      â”‚
â”‚  - Secrets: Vault/Cloud Secrets*                                           â”‚
â”‚  - Observability: Logs/Metrics/Traces*                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Legend:
* = optional im MVP, aber architektonisch vorgesehen
```

---

# 2) draw.io-Struktur (Swimlanes + Boxen + Pfeile)

## 2.1 Swimlanes (horizontal)

1. **Users**
2. **Backstage (IDP UI)**
3. **IDP Control Plane (Orchestrator)**
4. **Toolchain (CI/CD, Registry, IAM)**
5. **Runtime (Kubernetes/Execution)**
6. **Governance (Audit/KPIs)**

---

## 2.2 Boxen pro Swimlane

### Swimlane 1: Users

* **Developers**

### Swimlane 2: Backstage (IDP UI)

* **Backstage UI**
* **Software Catalog**
* **TechDocs**
* **Scaffolder (Templates/Forms)**
* *(optional)* Plugins: CI/CD Viewer, Kubernetes, Observability

### Swimlane 3: IDP Control Plane (Orchestrator)

* **IDP Orchestrator API**
* **Policy/Guardrail Engine**
* **Audit/Event Logger**
* **Adapters/Connectors** (CI/CD Adapter, Registry Adapter, IAM Adapter)

### Swimlane 4: Toolchain

* **SSO/IAM** (Entra/Keycloak/â€¦)
* **CI/CD System** (ADO/GitLab/GHA/â€¦)
* **Artifact Registry** (Container/Packages)
* *(optional)* Security Scans (SAST/SCA/SBOM)

### Swimlane 5: Runtime

* **Kubernetes Dev**
* **Kubernetes Test**
* *(optional)* Gatekeeper/Kyverno
* *(optional)* Secrets Store

### Swimlane 6: Governance

* **Metrics/KPI Store**
* **Dashboards/Reports**
* **Audit Store**

---

## 2.3 Pfeile (Flow)

### A) Golden Path: Deploy to Dev

1. Developers â†’ Backstage UI
2. Backstage Scaffolder â†’ IDP Orchestrator API (`POST /deploy`)
3. Orchestrator â†’ Policy Engine (RBAC + Env Rules + Validations)
4. Policy OK â†’ Orchestrator â†’ CI/CD (trigger pipeline)
5. CI/CD â†’ Registry (build/push artifact)
6. CI/CD â†’ Runtime Dev (deploy/apply)
7. Runtime/CI â†’ Orchestrator (status callback)
8. Orchestrator â†’ Backstage (Run URL/Status)
9. Orchestrator â†’ Audit/KPI (events)

### B) Promote to Test (mit Guardrails)

1. Backstage â†’ Orchestrator (`POST /promote`)
2. Policy Engine: nur `main/tag`, ggf. Approval
3. CI/CD deployt nach Runtime Test
4. Audit/KPI Updates

---

# 3) Mini-Big-Picture (Sequence in 6 Zeilen)

```
Backstage (Template) â†’ Orchestrator â†’ Policy Check â†’ CI/CD â†’ Runtime â†’ Audit/KPIs
```

---

Wenn du willst, mache ich als **nÃ¤chsten Schritt** (ohne weitere Fragen) eins von beiden:

* **A)** ein draw.io-XML, das du direkt importieren kannst, *oder*
* **B)** die gleiche Architektur als **Mermaid** (fÃ¼r Markdown/Docs).

Sag einfach: **â€Aâ€œ** oder **â€Bâ€œ**.




Hier ist ein **fertig importierbares draw.io (.drawio) XML** fÃ¼r die IDP-Prototyp-Architektur (mit Swimlanes + Boxen + Pfeilen), so wie im ASCII-Bild.

**So importierst du es in diagrams.net (draw.io):**

1. Ã–ffne diagrams.net
2. **File â†’ Import From â†’ Device** (oder: **File â†’ Open Fromâ€¦**)
3. Speichere den Inhalt unten als Datei **`idp-architecture.drawio`** und Ã¶ffne sie.

Verstanden â€” das liegt daran, dass mein erstes Diagramm eher â€œfunktionalâ€ als **layout-sauber** war (keine echten Swimlanes, uneinheitliche AbstÃ¤nde, Pfeile kreuzen sich schnell).

Hier ist eine **saubere Version** mit echten **Swimlanes**, sauberer Ausrichtung, konsistenten Box-GrÃ¶ÃŸen und **orthogonalen (rechtwinkligen) Connectors**. Das ist in draw.io deutlich â€œcleanerâ€ und wirkt wie ein Architektur-Poster.

## âœ… Neue Datei: `idp-architecture-clean.drawio`

**Import:**

* diagrams.net â†’ **File â†’ Import From â†’ Device**
* Datei erstellen + Inhalt speichern

```xml
<mxfile host="app.diagrams.net" modified="2026-01-22T17:10:00.000Z" agent="GPT" version="22.1.0" type="device">
  <diagram id="idp-prototype-arch-clean" name="IDP Prototype Architecture (Clean)">
    <mxGraphModel dx="1400" dy="900" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="1600" pageHeight="900" math="0" shadow="0">
      <root>
        <mxCell id="0"/>
        <mxCell id="1" parent="0"/>

        <!-- GLOBAL STYLE NOTE:
             - Swimlanes: swimlane=1, startSize=34 for header
             - Vertices: rounded=1, white fill, colored stroke per lane
             - Edges: orthogonal, block arrow
        -->

        <!-- Swimlane: Users -->
        <mxCell id="L_USERS" value="Users" style="swimlane=1;rounded=0;whiteSpace=wrap;html=1;startSize=34;fillColor=#f5f5f5;strokeColor=#b3b3b3;fontStyle=1;horizontal=1;" vertex="1" parent="1">
          <mxGeometry x="20" y="20" width="1560" height="120" as="geometry"/>
        </mxCell>

        <!-- Swimlane: Backstage -->
        <mxCell id="L_BACKSTAGE" value="Backstage (IDP UI)" style="swimlane=1;rounded=0;whiteSpace=wrap;html=1;startSize=34;fillColor=#eef6ff;strokeColor=#8fb3ff;fontStyle=1;horizontal=1;" vertex="1" parent="1">
          <mxGeometry x="20" y="150" width="1560" height="170" as="geometry"/>
        </mxCell>

        <!-- Swimlane: Control Plane -->
        <mxCell id="L_CONTROL" value="IDP Control Plane (Orchestrator)" style="swimlane=1;rounded=0;whiteSpace=wrap;html=1;startSize=34;fillColor=#f0fff4;strokeColor=#76c893;fontStyle=1;horizontal=1;" vertex="1" parent="1">
          <mxGeometry x="20" y="330" width="1560" height="190" as="geometry"/>
        </mxCell>

        <!-- Swimlane: Toolchain -->
        <mxCell id="L_TOOLCHAIN" value="Toolchain (CI/CD, Registry, IAM)" style="swimlane=1;rounded=0;whiteSpace=wrap;html=1;startSize=34;fillColor=#fff7ed;strokeColor=#f5a45d;fontStyle=1;horizontal=1;" vertex="1" parent="1">
          <mxGeometry x="20" y="530" width="1560" height="200" as="geometry"/>
        </mxCell>

        <!-- Swimlane: Runtime -->
        <mxCell id="L_RUNTIME" value="Runtime (Execution Plane)" style="swimlane=1;rounded=0;whiteSpace=wrap;html=1;startSize=34;fillColor=#fdf2f8;strokeColor=#f38ba8;fontStyle=1;horizontal=1;" vertex="1" parent="1">
          <mxGeometry x="20" y="740" width="1560" height="140" as="geometry"/>
        </mxCell>

        <!-- USERS nodes -->
        <mxCell id="N_DEVS" value="Developers&#xa;- use IDP&#xa;- trigger Deploy/Promote&#xa;- consume Golden Path docs" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#666666;" vertex="1" parent="L_USERS">
          <mxGeometry x="40" y="44" width="360" height="60" as="geometry"/>
        </mxCell>

        <!-- BACKSTAGE nodes (aligned row) -->
        <mxCell id="N_UI" value="Backstage UI&#xa;(Portal / Home / Golden Path)" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#4f7cff;" vertex="1" parent="L_BACKSTAGE">
          <mxGeometry x="40" y="54" width="300" height="80" as="geometry"/>
        </mxCell>

        <mxCell id="N_CATALOG" value="Software Catalog&#xa;- Systems&#xa;- Components&#xa;- Groups (Owners)" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#4f7cff;" vertex="1" parent="L_BACKSTAGE">
          <mxGeometry x="360" y="54" width="300" height="80" as="geometry"/>
        </mxCell>

        <mxCell id="N_TECHDOCS" value="TechDocs&#xa;Golden Path + Runbooks" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#4f7cff;" vertex="1" parent="L_BACKSTAGE">
          <mxGeometry x="680" y="54" width="300" height="80" as="geometry"/>
        </mxCell>

        <mxCell id="N_SCAFFOLDER" value="Scaffolder Templates&#xa;Deploy / Promote&#xa;(guided form + validation)" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#4f7cff;" vertex="1" parent="L_BACKSTAGE">
          <mxGeometry x="1000" y="54" width="300" height="80" as="geometry"/>
        </mxCell>

        <mxCell id="N_PLUGINS" value="Plugins (optional)&#xa;- CI/CD viewer&#xa;- Kubernetes&#xa;- Observability" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#4f7cff;dashed=1;" vertex="1" parent="L_BACKSTAGE">
          <mxGeometry x="1320" y="54" width="200" height="80" as="geometry"/>
        </mxCell>

        <!-- CONTROL PLANE nodes -->
        <mxCell id="N_ORCH" value="IDP Orchestrator API&#xa;POST /deploy&#xa;POST /promote" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#2f9e44;" vertex="1" parent="L_CONTROL">
          <mxGeometry x="40" y="64" width="320" height="90" as="geometry"/>
        </mxCell>

        <mxCell id="N_POLICY" value="Policy / Guardrail Engine&#xa;- RBAC (team/owner)&#xa;- env rules (dev/test)&#xa;- naming/metadata&#xa;- required checks" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#2f9e44;" vertex="1" parent="L_CONTROL">
          <mxGeometry x="380" y="54" width="420" height="110" as="geometry"/>
        </mxCell>

        <mxCell id="N_ADAPTERS" value="Adapters / Connectors&#xa;- CI/CD adapter&#xa;- Registry adapter&#xa;- IAM adapter" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#2f9e44;" vertex="1" parent="L_CONTROL">
          <mxGeometry x="820" y="64" width="340" height="90" as="geometry"/>
        </mxCell>

        <mxCell id="N_AUDIT" value="Audit &amp; Events&#xa;- who/what/when&#xa;- KPI event stream" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#2f9e44;" vertex="1" parent="L_CONTROL">
          <mxGeometry x="1180" y="64" width="340" height="90" as="geometry"/>
        </mxCell>

        <!-- TOOLCHAIN nodes -->
        <mxCell id="N_IAM" value="SSO / IAM&#xa;(Entra / Keycloak â€¦)" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#e8590c;" vertex="1" parent="L_TOOLCHAIN">
          <mxGeometry x="40" y="64" width="260" height="95" as="geometry"/>
        </mxCell>

        <mxCell id="N_CICD" value="CI/CD System&#xa;(ADO / GitLab / GHA / Jenkins)" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#e8590c;" vertex="1" parent="L_TOOLCHAIN">
          <mxGeometry x="320" y="64" width="340" height="95" as="geometry"/>
        </mxCell>

        <mxCell id="N_REG" value="Artifact Registry&#xa;(Container / Packages)" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#e8590c;" vertex="1" parent="L_TOOLCHAIN">
          <mxGeometry x="680" y="64" width="300" height="95" as="geometry"/>
        </mxCell>

        <mxCell id="N_SCANS" value="Security Scans (optional)&#xa;- SAST&#xa;- SCA/SBOM" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#e8590c;dashed=1;" vertex="1" parent="L_TOOLCHAIN">
          <mxGeometry x="1000" y="64" width="260" height="95" as="geometry"/>
        </mxCell>

        <mxCell id="N_METRICS" value="Metrics / Logging Sink&#xa;(KPIs + audit)" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#e8590c;" vertex="1" parent="L_TOOLCHAIN">
          <mxGeometry x="1280" y="64" width="240" height="95" as="geometry"/>
        </mxCell>

        <!-- RUNTIME nodes -->
        <mxCell id="N_DEV" value="Kubernetes DEV" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#c2255c;" vertex="1" parent="L_RUNTIME">
          <mxGeometry x="40" y="54" width="280" height="70" as="geometry"/>
        </mxCell>

        <mxCell id="N_TEST" value="Kubernetes TEST" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#c2255c;" vertex="1" parent="L_RUNTIME">
          <mxGeometry x="340" y="54" width="280" height="70" as="geometry"/>
        </mxCell>

        <mxCell id="N_RUNTIME_POLICY" value="Runtime Policy (optional)&#xa;Gatekeeper / Kyverno" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#c2255c;dashed=1;" vertex="1" parent="L_RUNTIME">
          <mxGeometry x="640" y="54" width="320" height="70" as="geometry"/>
        </mxCell>

        <mxCell id="N_SECRETS" value="Secrets (optional)&#xa;Vault / Cloud Secrets" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#c2255c;dashed=1;" vertex="1" parent="L_RUNTIME">
          <mxGeometry x="980" y="54" width="260" height="70" as="geometry"/>
        </mxCell>

        <mxCell id="N_OBS" value="Observability (optional)&#xa;Logs / Metrics / Traces" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#c2255c;dashed=1;" vertex="1" parent="L_RUNTIME">
          <mxGeometry x="1260" y="54" width="260" height="70" as="geometry"/>
        </mxCell>

        <!-- EDGES (orthogonal + tidy) -->
        <mxCell id="E1" value="use" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;endArrow=block;endFill=1;strokeColor=#444444;" edge="1" parent="1" source="N_DEVS" target="N_UI">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E2" value="submit request" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;endArrow=block;endFill=1;strokeColor=#4f7cff;" edge="1" parent="1" source="N_UI" target="N_SCAFFOLDER">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E3" value="resolve owner/context" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;endArrow=block;endFill=1;strokeColor=#4f7cff;" edge="1" parent="1" source="N_SCAFFOLDER" target="N_CATALOG">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E4" value="open runbooks" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;endArrow=block;endFill=1;strokeColor=#4f7cff;" edge="1" parent="1" source="N_UI" target="N_TECHDOCS">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E5" value="POST /deploy | /promote" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;endArrow=block;endFill=1;strokeColor=#2f9e44;" edge="1" parent="1" source="N_SCAFFOLDER" target="N_ORCH">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E6" value="policy check" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;endArrow=block;endFill=1;strokeColor=#2f9e44;" edge="1" parent="1" source="N_ORCH" target="N_POLICY">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E7" value="authz" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;endArrow=block;endFill=1;strokeColor=#e8590c;" edge="1" parent="1" source="N_POLICY" target="N_IAM">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E8" value="approved â†’ adapters" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;endArrow=block;endFill=1;strokeColor=#2f9e44;" edge="1" parent="1" source="N_POLICY" target="N_ADAPTERS">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E9" value="trigger pipeline" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;endArrow=block;endFill=1;strokeColor=#e8590c;" edge="1" parent="1" source="N_ADAPTERS" target="N_CICD">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E10" value="build &amp; push" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;endArrow=block;endFill=1;strokeColor=#e8590c;" edge="1" parent="1" source="N_CICD" target="N_REG">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E11" value="deploy DEV" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;endArrow=block;endFill=1;strokeColor=#c2255c;" edge="1" parent="1" source="N_CICD" target="N_DEV">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E12" value="deploy TEST" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;endArrow=block;endFill=1;strokeColor=#c2255c;" edge="1" parent="1" source="N_CICD" target="N_TEST">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E13" value="audit events" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;endArrow=block;endFill=1;strokeColor=#2f9e44;" edge="1" parent="1" source="N_ORCH" target="N_AUDIT">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E14" value="KPIs" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;endArrow=block;endFill=1;strokeColor=#e8590c;" edge="1" parent="1" source="N_AUDIT" target="N_METRICS">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E15" value="scan gates (optional)" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;endArrow=block;endFill=1;strokeColor=#e8590c;dashed=1;" edge="1" parent="1" source="N_CICD" target="N_SCANS">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E16" value="runtime policy (optional)" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;endArrow=block;endFill=1;strokeColor=#c2255c;dashed=1;" edge="1" parent="1" source="N_DEV" target="N_RUNTIME_POLICY">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E17" value="runtime policy (optional)" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;endArrow=block;endFill=1;strokeColor=#c2255c;dashed=1;" edge="1" parent="1" source="N_TEST" target="N_RUNTIME_POLICY">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
```

### Was hier â€saubererâ€œ ist

* **Echte Swimlanes** (nicht nur Hintergrundbalken)
* **GleichmÃ¤ÃŸige Grid-AbstÃ¤nde** (40/20/10er Raster)
* **Gleiche Box-Breiten** pro Reihe â†’ ruhiger Look
* **Orthogonale Kanten** (rechtwinklig statt wild)
* **Optional** klar als *gestrichelt* markiert

Wenn du mir sagst, ob du **Dev/Test wirklich als K8s** zeigen willst (oder z. B. â€œVM/Cloudâ€), passe ich dir die Runtime-Zeile sofort in der gleichen sauberen Optik an.





<img width="937" height="518" alt="image" src="https://github.com/user-attachments/assets/dcea604d-6f94-4c12-8fb7-654b4852961b" />




Klar â€” ich beschreibe dir das Diagramm **genau im Kontext eures Projekts**: ein **IDP-Prototyp** (Backstage) fÃ¼r ein DevOps/Platform-Team, das **Self-Service Deployments mit Guardrails** ermÃ¶glichen will und dabei **Developer Experience (DX)** messbar verbessern mÃ¶chte.

---

## Was das Diagramm insgesamt zeigt

Das Diagramm ist eine **End-to-End-Architektur** fÃ¼r den MVP-Use-Case:

> **Developer klickt in Backstage â€œDeploy/Promoteâ€ â†’ Plattform prÃ¼ft Guardrails â†’ Pipeline lÃ¤uft â†’ Deployment passiert â†’ Audit/KPIs werden erfasst**

Die farbigen Bereiche sind **Schichten (Swimlanes)**:

* **Blau = Backstage / IDP UI** (Developer Experience Layer)
* **GrÃ¼n = Control Plane / Orchestrator** (Plattformlogik + Guardrails)
* **Orange = Toolchain** (IAM, CI/CD, Registry, Scans, Metrics)
* **Pink = Runtime** (Kubernetes DEV/TEST + optionale Runtime-Policies/Secrets/Observability)
* **Gestrichelt = optional im MVP**, aber fÃ¼r die Zukunft vorgesehen

---

## 1) Users (oben)

### **Developers**

* **trigger: Deploy / Promote**
* **consume: Golden Path docs**

â¡ï¸ Das ist genau euer Ziel aus der Problemstellung: Entwickler sollen **selbststÃ¤ndig** handeln kÃ¶nnen, aber innerhalb definierter Leitplanken.

---

## 2) Backstage (blauer Bereich): â€œFrontdoorâ€ & DX-Layer

### **Backstage UI**

* zentraler Einstiegspunkt: Portal/Home/Golden Path

### **Software Catalog**

* enthÃ¤lt die Wahrheit Ã¼ber:

  * Services/Components
  * Teams/Owner (â€œGroupsâ€)
* wichtig, weil daraus **Ownership, Routing und RBAC** abgeleitet werden

### **TechDocs**

* Golden Path + Runbooks â€œam Point of Needâ€
* reduziert kognitive Last und macht Adoption wahrscheinlicher

### **Scaffolder Templates**

* â€œDeploy/Promoteâ€ als gefÃ¼hrtes Formular + Validation
* verhindert unklare Requests und erzwingt Standardisierung
* fÃ¼r euren MVP: **ein Template reicht**, z. B. â€œDeploy to Devâ€ (und optional Promote)

### **Plugins (optional)**

* CI/CD Viewer, Kubernetes, Observability
* sind nicht zwingend fÃ¼r MVP, aber verbessern die **Developer Experience**, weil Status direkt in Backstage sichtbar wird

â¡ï¸ Bedeutung fÃ¼rs Projekt: Hier lebt die **Developer Experience** (Self-Service, Discoverability, Dokumentation, klare Handlungswege).

---

## 3) IDP Control Plane (grÃ¼ner Bereich): Guardrails & Orchestrierung

### **IDP Orchestrator API**

* Endpunkte wie: `POST /deploy`, `POST /promote`
* Backstage ruft diese API auf â†’ Backstage bleibt UI/Portal, Logik bleibt zentral im Orchestrator

### **Policy / Guardrail Engine**

Hier steckt euer Kernversprechen:

* **RBAC (team/owner)**: nur berechtigte Rollen/Teams dÃ¼rfen deployen
* **Environment rules (dev/test)**: z. B. Dev frei, Test nur main/tag
* **Naming/Metadata**: Standards erzwingen (z. B. Version/Branch-Regeln)
* **Required checks**: z. B. Security-Scan muss grÃ¼n sein, bevor Promote erlaubt ist

### **IDP Control Plane (Orchestrator)**

Das ist der â€œControllerâ€:

* entscheidet nach Policy Check:

  * **approve â†’ adapters**
  * oder **reject** (mit sauberer Fehlermeldung â†’ wichtig fÃ¼r DX!)

### **Adapters / Connectors**

Entkopplung von Tools:

* CI/CD adapter
* Registry adapter
* IAM adapter

â¡ï¸ Bedeutung fÃ¼rs Projekt: Das ist die **skalierbare Architektur**. Backstage bleibt stabil, Tools kÃ¶nnen wechseln (Cloud-Native, Microservices, neue Scanner), weil nur Adapter angepasst werden.

### **Audit & Events**

* â€œwho/what/whenâ€
* KPI Event Stream

â¡ï¸ Das erfÃ¼llt euren Forschungs-/Evaluationsauftrag: **DX-KPIs definieren, messen, verbessern**.

---

## 4) Toolchain (oranger Bereich): â€œExecution & Evidenceâ€

### **SSO / IAM**

* z. B. Entra/Keycloak
* liefert IdentitÃ¤t und Rollen â†’ Grundlage fÃ¼r RBAC/Compliance

### **CI/CD System**

* ADO / GitLab / GitHub Actions / Jenkins
* fÃ¼hrt den Build/Deploy tatsÃ¤chlich aus

### **Artifact Registry**

* Container/Packages
* â€œbuild & pushâ€ im Diagramm: Pipeline erstellt Artefakt und legt es im Registry ab

### **Security Scans (optional)**

* SAST, SCA/SBOM
* im Diagramm gestrichelt: MVP kann ohne starten, aber fÃ¼r Compliance sehr wertvoll
* ideal als **required check** in der Policy Engine

### **Metrics / Logging Sink**

* KPIs + Audit werden hier gesammelt
* Grundlage fÃ¼r Dashboards (Lead Time, Deployment Frequency, Failure Rate, Self-Service-Quote)

â¡ï¸ Bedeutung fÃ¼rs Projekt: Diese Schicht liefert die **Nachweise** (Compliance/Audit) und die **Messbarkeit** (DX-KPIs).

---

## 5) Runtime (pinker Bereich): â€œDeploy Targetsâ€

### **Kubernetes DEV / Kubernetes TEST**

* der MVP zeigt: Deploy in DEV und optional Promote nach TEST
* genau der Self-Service Use Case, der Business Value bringt

### Optional (gestrichelt)

* **Runtime Policy (Gatekeeper/Kyverno)**: Policies direkt im Cluster erzwingen (zweite Sicherheitslinie)
* **Secrets (Vault/Cloud Secrets)**: sichere Secret-Verwaltung
* **Observability**: Logs/Metrics/Traces (DX verbessert, MTTR sinkt)

â¡ï¸ Bedeutung fÃ¼rs Projekt: Zukunftssicher (Cloud-Native/Microservices), aber MVP kann klein bleiben.

---

## Der zentrale â€œGolden Pathâ€ Ablauf im Diagramm (in Worten)

1. Developer â†’ Backstage UI â†’ startet **Deploy/Promote**
2. Scaffolder Template â†’ sendet Request an **Orchestrator API**
3. Orchestrator â†’ **Policy/Guardrail Check** (RBAC, env rules, required checks)
4. Wenn ok â†’ Orchestrator â†’ **Adapters** â†’ **CI/CD triggern**
5. CI/CD â†’ **build & push** ins Registry â†’ Deploy nach **K8s DEV/TEST**
6. Orchestrator/Audit â†’ Events + KPIs â†’ Metrics Sink

---

## Warum dieses Diagramm sehr gut zu eurer Problemdefinition passt

* **Self-Service MVP** ist klar sichtbar (Backstage Templates â†’ Deploy/Promote)
* **Guardrails** sind zentrale Schicht (Policy Engine + optional Runtime Policies)
* **Compliance & Konsistenz**: required checks, Audit, Policies, standardisierte Flows
* **DX / Adoption**: Golden Path + TechDocs + UI-Buttons + klare Feedbacks
* **Skalierbarkeit & Zukunft**: Adapter-Architektur + optionale Cloud-Native Bausteine

---

Wenn du willst, mache ich als nÃ¤chsten Schritt (ohne dich mit Details zu erschlagen) eine **MVP-Markierung** direkt auf Architektur-Ebene:

* **MVP (Sprint 1â€“2)**: Backstage + Catalog + TechDocs + Deploy Template + Orchestrator + CI Trigger + DEV Deploy + Audit Events
* **Phase 2**: Promote + required checks + Security Scans
* **Phase 3**: Runtime Policies + Secrets + Observability + KPI Dashboard

Sag einfach: **â€œJa, MVP/Phase 2/3 bitte einzeichnenâ€** oder **â€œJetzt Template bauenâ€**.



Unten ist eine **wissenschaftlich-intellektuelle, aber flÃ¼ssig erzÃ¤hlbare** Beschreibung, die du **1:1 als Vortragsskript** (z. B. 5â€“8 Minuten) nutzen kannst. Ich binde **prÃ¤zise Beispiele** ein und knÃ¼pfe alles eng an eure Zielsetzung: **Self-Service-MVP mit Guardrails, DX-Evaluation, Compliance und Skalierbarkeit**.

---

## 1) Einordnung: Was dieses Diagramm konzeptionell abbildet

Dieses Architekturdiagramm beschreibt eine **Internal Developer Platform (IDP)** als **sozio-technisches System**, das zwei Ziele gleichzeitig optimiert:

1. **Autonomie der Entwicklungsteams** (Self-Service, schnelle Deployments, weniger AbhÃ¤ngigkeiten)
2. **Governance-Anforderungen** (Sicherheit, Compliance, Konsistenz, Nachvollziehbarkeit)

Aus wissenschaftlicher Sicht ist das eine klassische **Spannung zwischen Local Optimization und Global Constraints**: Teams wollen Geschwindigkeit, Organisationen wollen Risikokontrolle. Das Diagramm zeigt, wie man diese Spannung durch eine **zweistufige Steuerungsarchitektur** lÃ¶st:

* **Experience Layer (Backstage)**: reduziert kognitive Last, standardisiert Interaktionen
* **Control Plane (Orchestrator + Policies)**: erzwingt Guardrails und erzeugt Audit-Evidenz
* **Execution Plane (CI/CD + Runtime)**: fÃ¼hrt Ã„nderungen deterministisch aus

Damit folgt die IDP dem Prinzip **â€Paved Roads / Golden Pathsâ€œ**: Der einfachste Weg ist der sichere Weg.

---

## 2) LeseschlÃ¼ssel: Die Schichten (Swimlanes) und ihre Funktion

### (A) Users: â€Intentâ€œ statt Ticket

Oben steht der Entwickler als **Intent-Quelle**: nicht â€bitte deployenâ€œ, sondern â€ich will Version X in DEV testenâ€œ. Das ist wichtig: Die Plattform muss **Absichten** in **konforme AusfÃ¼hrung** Ã¼bersetzen.

**Beispiel:**
Ein Entwickler mÃ¶chte den Service `payments-api` in die DEV-Umgebung deployen, um einen Fix zu verifizieren.

---

### (B) Backstage (blau): â€Developer Experience Layerâ€œ

Backstage ist im Diagramm die **Frontdoor** â€“ eine ergonomische Schnittstelle, die drei DX-Hebel kombiniert:

1. **Software Catalog** (Kontext & Ownership)
2. **TechDocs** (Wissen am Point of Need)
3. **Scaffolder Templates** (standardisierte Self-Service-Aktionen)

**Warum ist das wissenschaftlich relevant?**
Weil DX hÃ¤ufig an **kognitiver Last** scheitert: Entwickler verlieren Zeit nicht an Technik, sondern an *Suchen, RÃ¼ckfragen, Unklarheiten*. Der Catalog reduziert â€Wer ist zustÃ¤ndig?â€œ; Templates reduzieren VariabilitÃ¤t; TechDocs reduzieren Suchkosten.

**PrÃ¤zises Beispiel:**
Der Entwickler klickt nicht â€Deploy irgendwieâ€œ, sondern nutzt ein Template:

* Service: `payments-api` (aus dem Catalog)
* Ziel: `DEV`
* Version: `feature/refund-fix` oder ein Release-Tag

Das Template erzwingt Pflichtfelder und validiert Eingaben (z. B. Branch-Format). Das ist bereits eine **erste Guardrail**, allerdings noch im UX-Layer.

---

### (C) Control Plane (grÃ¼n): â€Policy-Enforcement und Orchestrierungâ€œ

Hier liegt der intellektuelle Kern: Backstage ist nicht die Instanz, die Governance garantiert. Das Ã¼bernimmt die **IDP Control Plane** (Orchestrator).

Sie hat drei Rollen:

1. **Interpretation des Intents** (Deploy/Promote Request)
2. **Policy/Guardrail Checks** (RBAC, Environment-Regeln, Required Checks)
3. **Orchestrierung der Toolchain** (Adapter zu CI/CD, Registry, IAM)

In Plattform-Engineering-Begriffen ist das der Unterschied zwischen **Portal** und **Produktionssystem**:
Backstage optimiert Interaktion, die Control Plane optimiert Kontrolle und Skalierung.

**PrÃ¤zises Beispiel (Guardrails):**

* **RBAC-Regel:** Nur Mitglieder des Owner-Teams dÃ¼rfen `payments-api` deployen.
  â†’ Der Orchestrator verifiziert TeamzugehÃ¶rigkeit Ã¼ber IAM/SSO.
* **Environment-Regel:**

  * DEV: branch-deploy erlaubt
  * TEST: nur `main` oder Release-Tags (z. B. `v1.3.2`)
* **Required Checks:** Bevor ein Promote nach TEST erlaubt ist, muss ein Security-Scan grÃ¼n sein.

Wichtig ist hier: Guardrails sind **nicht** als Dokument formuliert, sondern als **entscheidbare Regeln**. Das ist der Schritt von â€Policy as PDFâ€œ zu **Policy as Code**.

---

### (D) Toolchain (orange): â€AusfÃ¼hrung + Evidenzâ€œ

Die Toolchain-Schicht zeigt die Systeme, die tatsÃ¤chlich rechnen, bauen und deployen:

* **SSO/IAM** liefert IdentitÃ¤t und Rollen (Grundlage fÃ¼r Compliance-fÃ¤hige Autorisierung)
* **CI/CD** fÃ¼hrt deterministische Pipelines aus
* **Artifact Registry** stellt Artefakte bereit (Reproduzierbarkeit)
* **Security Scans (optional)** liefern PrÃ¼fnachweise (SAST, SCA/SBOM)
* **Metrics/Logging Sink** sammelt Events (DX-KPIs, Audit)

**PrÃ¤zises Beispiel (Pipeline):**
Nach Policy-OK triggert der Orchestrator eine Pipeline:

1. Build `payments-api`
2. Unit tests
3. Container Image bauen
4. Push nach Registry
5. Deploy nach DEV (oder Promote nach TEST)

Damit wird Self-Service nicht â€wildâ€œ, sondern **produktionsnah standardisiert**.

---

### (E) Runtime (pink): â€Execution Planeâ€œ

Hier liegt das Zielsystem: Kubernetes DEV/TEST. Optional ergÃ¤nzt:

* **Runtime Policy** (Gatekeeper/Kyverno): zweite Verteidigungslinie
* **Secrets** (Vault): sichere Verteilung von Credentials
* **Observability** (Logs/Metrics/Traces): Feedback-Loop, MTTR

**PrÃ¤zises Beispiel (Runtime Guardrail):**
Selbst wenn jemand versucht, einen Pod mit `privileged=true` zu deployen, blockt Gatekeeper das. Das ist ein Governance-Mechanismus auf Runtime-Ebene, unabhÃ¤ngig vom Portal.

---

## 3) Der Golden-Path Ablauf: eine flÃ¼ssig erzÃ¤hlbare Sequenz

Du kannst das Diagramm elegant so erklÃ¤ren:

> â€Ein Developer Ã¤uÃŸert in Backstage eine Absicht: â€˜Deploy payments-api nach DEVâ€™. Backstage liefert Kontext (Owner, System, Doku) und zwingt strukturierte Eingaben. Der Request wird dann an die Control Plane Ã¼bergeben â€“ dort entscheidet die Policy-Engine, ob diese Absicht innerhalb unserer Leitplanken liegt. Wenn ja, orchestriert der Orchestrator die AusfÃ¼hrung Ã¼ber CI/CD, baut ein reproduzierbares Artefakt im Registry und deployed in die Zielumgebung. Gleichzeitig erzeugt er Audit-Events und KPI-Daten, sodass wir nicht nur deployen, sondern auch messen: wie schnell, wie zuverlÃ¤ssig und wie autonom Teams arbeiten.â€œ

Das ist der â€Narrativâ€œ: **Intent â†’ Policy Decision â†’ Automated Execution â†’ Evidence**.

---

## 4) Warum diese Architektur wissenschaftlich â€sauberâ€œ ist

### 4.1 Separation of Concerns

* Backstage: **UX & Discoverability**
* Orchestrator: **Decision & Governance**
* CI/CD + Runtime: **Execution**
* Audit/Metrics: **Evidence**

Das ist im Kern ein Entwurf nach Prinzipien aus verteilten Systemen: Verantwortlichkeiten sind so getrennt, dass Ã„nderungen in Tools nicht das Portal destabilisieren.

### 4.2 Skalierung Ã¼ber Adapter

Die Adapter/Connectors bedeuten:
Man kann Azure DevOps spÃ¤ter durch GitLab ersetzen, ohne den Golden Path zu zerstÃ¶ren. Backstage bleibt stabil; nur Adapter Ã¤ndern sich. Das ist **evolvierbare Architektur**.

### 4.3 Compliance als Emergent Property durch Evidenz

Compliance entsteht nicht durch Absicht, sondern durch **Evidenz**: Audit Events + Policy Checks + reproduzierbare Builds. Das Diagramm zeigt bewusst die Event-Spur, damit Governance prÃ¼fbar wird.

---

## 5) PrÃ¤zise Beispiele, die du beim Zeigen des Diagramms erwÃ¤hnen kannst

### Beispiel 1: â€œDeploy to DEVâ€ (MVP-Use-Case)

* Entwickler wÃ¤hlt `payments-api`, Environment `DEV`, Branch `feature/refund-fix`
* Policy: DEV erlaubt Branch-Deploy
* Pipeline lÃ¤uft, deployed nach DEV
* Event: `deploy_started`, `deploy_succeeded`, Dauer = 6 Minuten
* KPI: *Time-to-Deploy* verbessert sich (z. B. von Stunden auf Minuten)

### Beispiel 2: â€œPromote to TESTâ€ (Guardrail demonstrieren)

* Entwickler wÃ¤hlt `payments-api`, Environment `TEST`, Branch `feature/*`
* Policy Engine verweigert: TEST nur `main` oder Tag
* Fehlermeldung ist DX-relevant: â€œPromote to TEST requires main or release tag (vX.Y.Z).â€
* Entwickler lernt den Golden Path, statt Tickets zu erÃ¶ffnen

### Beispiel 3: â€œSecurity Gateâ€

* Promote nach TEST erfordert SCA/SBOM ok
* Scan findet kritische CVE â†’ Promote blockiert
* Ergebnis: Governance wird *aktiv* durchgesetzt, nicht nur dokumentiert

---

## 6) Schluss: Warum das fÃ¼r eure Forschungsziele passt (DX + Platform Engineering)

Am Ende kannst du die Architektur in einen Satz verdichten:

> â€Diese IDP trennt Developer Experience von Governance, Ã¼bersetzt Entwickler-Intent in konforme, auditierbare Automatisierung und schafft damit die Grundlage, Developer Experience nicht nur zu behaupten, sondern anhand von KPIs zu evaluieren.â€œ

---

Wenn du mÃ¶chtest, schreibe ich dir als nÃ¤chstes:

* eine **2-Minuten-Kurzversion** (fÃ¼r Stakeholder) und
* eine **10-Minuten-Langversion** (fÃ¼r technische Review/Thesis),
  beide mit passenden ÃœbergÃ¤ngen und Formulierungen, die wirklich â€flÃ¼ssigâ€œ klingen.




Alles klar â€” wir machen **beides**:

1. **Diagramm**: MVP vs. Phase 2 vs. Phase 3 **sichtbar einzeichnen** (importierbares draw.io XML)
2. **Template bauen**: ein **Backstage Scaffolder Template** fÃ¼r euren Prototyp-Use-Case (*Deploy/Promote mit Guardrails via Orchestrator*)

---

# 1) draw.io Diagramm mit MVP / Phase 2 / Phase 3 (sauber eingezeichnet)

**Codierung im Diagramm**

* âœ… **MVP** = **durchgezogene** Boxen (normal)
* ğŸŸ§ **Phase 2** = **gestrichelt**
* ğŸŸª **Phase 3** = **punktiert** (dotted)
* ZusÃ¤tzlich: jedes Element trÃ¤gt **[MVP] / [P2] / [P3]** im Titel + eine **Legende**

**Import:**

* diagrams.net â†’ File â†’ Import From â†’ Device
* Datei als `idp-architecture-mvp-phases.drawio` speichern

```xml
<mxfile host="app.diagrams.net" modified="2026-01-22T18:10:00.000Z" agent="GPT" version="22.1.0" type="device">
  <diagram id="idp-prototype-arch-phases" name="IDP Prototype Architecture (MVP + Phases)">
    <mxGraphModel dx="1400" dy="900" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="1600" pageHeight="900" math="0" shadow="0">
      <root>
        <mxCell id="0"/>
        <mxCell id="1" parent="0"/>

        <!-- Swimlanes -->
        <mxCell id="L_USERS" value="Users" style="swimlane=1;rounded=0;whiteSpace=wrap;html=1;startSize=34;fillColor=#f5f5f5;strokeColor=#b3b3b3;fontStyle=1;horizontal=1;" vertex="1" parent="1">
          <mxGeometry x="20" y="20" width="1560" height="120" as="geometry"/>
        </mxCell>

        <mxCell id="L_BACKSTAGE" value="Backstage (IDP UI)" style="swimlane=1;rounded=0;whiteSpace=wrap;html=1;startSize=34;fillColor=#eef6ff;strokeColor=#8fb3ff;fontStyle=1;horizontal=1;" vertex="1" parent="1">
          <mxGeometry x="20" y="150" width="1560" height="170" as="geometry"/>
        </mxCell>

        <mxCell id="L_CONTROL" value="IDP Control Plane (Orchestrator)" style="swimlane=1;rounded=0;whiteSpace=wrap;html=1;startSize=34;fillColor=#f0fff4;strokeColor=#76c893;fontStyle=1;horizontal=1;" vertex="1" parent="1">
          <mxGeometry x="20" y="330" width="1560" height="190" as="geometry"/>
        </mxCell>

        <mxCell id="L_TOOLCHAIN" value="Toolchain (CI/CD, Registry, IAM)" style="swimlane=1;rounded=0;whiteSpace=wrap;html=1;startSize=34;fillColor=#fff7ed;strokeColor=#f5a45d;fontStyle=1;horizontal=1;" vertex="1" parent="1">
          <mxGeometry x="20" y="530" width="1560" height="200" as="geometry"/>
        </mxCell>

        <mxCell id="L_RUNTIME" value="Runtime (Execution Plane)" style="swimlane=1;rounded=0;whiteSpace=wrap;html=1;startSize=34;fillColor=#fdf2f8;strokeColor=#f38ba8;fontStyle=1;horizontal=1;" vertex="1" parent="1">
          <mxGeometry x="20" y="740" width="1560" height="140" as="geometry"/>
        </mxCell>

        <!-- Legend -->
        <mxCell id="LEGEND" value="Legend&#xa;âœ… [MVP] solid line&#xa;ğŸŸ§ [P2] dashed&#xa;ğŸŸª [P3] dotted" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#666666;fontStyle=1;" vertex="1" parent="1">
          <mxGeometry x="1290" y="35" width="290" height="95" as="geometry"/>
        </mxCell>

        <!-- USERS -->
        <mxCell id="N_DEVS" value="[MVP] Developers&#xa;- use IDP&#xa;- trigger Deploy/Promote&#xa;- consume Golden Path docs" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#666666;" vertex="1" parent="L_USERS">
          <mxGeometry x="40" y="44" width="420" height="60" as="geometry"/>
        </mxCell>

        <!-- BACKSTAGE (MVP core) -->
        <mxCell id="N_UI" value="[MVP] Backstage UI&#xa;(Portal / Home / Golden Path)" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#4f7cff;" vertex="1" parent="L_BACKSTAGE">
          <mxGeometry x="40" y="54" width="300" height="80" as="geometry"/>
        </mxCell>

        <mxCell id="N_CATALOG" value="[MVP] Software Catalog&#xa;- Systems&#xa;- Components&#xa;- Groups (Owners)" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#4f7cff;" vertex="1" parent="L_BACKSTAGE">
          <mxGeometry x="360" y="54" width="300" height="80" as="geometry"/>
        </mxCell>

        <mxCell id="N_TECHDOCS" value="[MVP] TechDocs&#xa;Golden Path + Runbooks" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#4f7cff;" vertex="1" parent="L_BACKSTAGE">
          <mxGeometry x="680" y="54" width="300" height="80" as="geometry"/>
        </mxCell>

        <mxCell id="N_SCAFFOLDER" value="[MVP] Scaffolder Template&#xa;Deploy (Dev)&#xa;(guided form + validation)&#xa;&#xa;[P2] Promote (Test) optional" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#4f7cff;" vertex="1" parent="L_BACKSTAGE">
          <mxGeometry x="1000" y="54" width="360" height="80" as="geometry"/>
        </mxCell>

        <mxCell id="N_PLUGINS" value="[P2] Plugins (DX boost)&#xa;- CI/CD viewer&#xa;- Kubernetes&#xa;- Observability" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#4f7cff;dashed=1;" vertex="1" parent="L_BACKSTAGE">
          <mxGeometry x="1380" y="54" width="140" height="80" as="geometry"/>
        </mxCell>

        <!-- CONTROL PLANE -->
        <mxCell id="N_ORCH" value="[MVP] IDP Orchestrator API&#xa;POST /deploy&#xa;&#xa;[P2] POST /promote" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#2f9e44;" vertex="1" parent="L_CONTROL">
          <mxGeometry x="40" y="64" width="320" height="90" as="geometry"/>
        </mxCell>

        <mxCell id="N_POLICY" value="[MVP] Policy / Guardrail Engine&#xa;- RBAC (team/owner)&#xa;- env rules (dev/test)&#xa;- naming/metadata&#xa;&#xa;[P2] required checks (scan gates)" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#2f9e44;" vertex="1" parent="L_CONTROL">
          <mxGeometry x="380" y="54" width="420" height="110" as="geometry"/>
        </mxCell>

        <mxCell id="N_ADAPTERS" value="[MVP] Adapters / Connectors&#xa;- CI/CD adapter&#xa;- IAM adapter&#xa;&#xa;[P2] Registry adapter" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#2f9e44;" vertex="1" parent="L_CONTROL">
          <mxGeometry x="820" y="64" width="340" height="90" as="geometry"/>
        </mxCell>

        <mxCell id="N_AUDIT" value="[MVP] Audit &amp; Events&#xa;- who/what/when&#xa;- KPI event stream" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#2f9e44;" vertex="1" parent="L_CONTROL">
          <mxGeometry x="1180" y="64" width="340" height="90" as="geometry"/>
        </mxCell>

        <!-- TOOLCHAIN -->
        <mxCell id="N_IAM" value="[MVP] SSO / IAM&#xa;(Entra / Keycloak â€¦)" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#e8590c;" vertex="1" parent="L_TOOLCHAIN">
          <mxGeometry x="40" y="64" width="260" height="95" as="geometry"/>
        </mxCell>

        <mxCell id="N_CICD" value="[MVP] CI/CD System&#xa;(ADO / GitLab / GHA / Jenkins)" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#e8590c;" vertex="1" parent="L_TOOLCHAIN">
          <mxGeometry x="320" y="64" width="360" height="95" as="geometry"/>
        </mxCell>

        <mxCell id="N_REG" value="[P2] Artifact Registry&#xa;(Container / Packages)" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#e8590c;dashed=1;" vertex="1" parent="L_TOOLCHAIN">
          <mxGeometry x="700" y="64" width="300" height="95" as="geometry"/>
        </mxCell>

        <mxCell id="N_SCANS" value="[P2] Security Scans&#xa;- SAST&#xa;- SCA/SBOM" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#e8590c;dashed=1;" vertex="1" parent="L_TOOLCHAIN">
          <mxGeometry x="1020" y="64" width="250" height="95" as="geometry"/>
        </mxCell>

        <mxCell id="N_METRICS" value="[MVP] Metrics / Logging Sink&#xa;(KPIs + audit)" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#e8590c;" vertex="1" parent="L_TOOLCHAIN">
          <mxGeometry x="1290" y="64" width="230" height="95" as="geometry"/>
        </mxCell>

        <!-- RUNTIME -->
        <mxCell id="N_DEV" value="[MVP] Kubernetes DEV" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#c2255c;" vertex="1" parent="L_RUNTIME">
          <mxGeometry x="40" y="54" width="300" height="70" as="geometry"/>
        </mxCell>

        <mxCell id="N_TEST" value="[P2] Kubernetes TEST" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#c2255c;dashed=1;" vertex="1" parent="L_RUNTIME">
          <mxGeometry x="360" y="54" width="300" height="70" as="geometry"/>
        </mxCell>

        <mxCell id="N_RUNTIME_POLICY" value="[P3] Runtime Policy Enforcement&#xa;Gatekeeper / Kyverno" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#c2255c;dashed=0;dotted=1;" vertex="1" parent="L_RUNTIME">
          <mxGeometry x="680" y="54" width="320" height="70" as="geometry"/>
        </mxCell>

        <mxCell id="N_SECRETS" value="[P3] Secrets Management&#xa;Vault / Cloud Secrets" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#c2255c;dashed=0;dotted=1;" vertex="1" parent="L_RUNTIME">
          <mxGeometry x="1020" y="54" width="250" height="70" as="geometry"/>
        </mxCell>

        <mxCell id="N_OBS" value="[P3] Observability&#xa;Logs / Metrics / Traces" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#c2255c;dashed=0;dotted=1;" vertex="1" parent="L_RUNTIME">
          <mxGeometry x="1290" y="54" width="230" height="70" as="geometry"/>
        </mxCell>

        <!-- EDGES (orthogonal) -->
        <mxCell id="E1" value="use" style="edgeStyle=orthogonalEdgeStyle;html=1;endArrow=block;endFill=1;strokeColor=#444444;" edge="1" parent="1" source="N_DEVS" target="N_UI">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E2" value="submit (deploy/promote)" style="edgeStyle=orthogonalEdgeStyle;html=1;endArrow=block;endFill=1;strokeColor=#4f7cff;" edge="1" parent="1" source="N_UI" target="N_SCAFFOLDER">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E3" value="resolve owner/context" style="edgeStyle=orthogonalEdgeStyle;html=1;endArrow=block;endFill=1;strokeColor=#4f7cff;" edge="1" parent="1" source="N_SCAFFOLDER" target="N_CATALOG">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E4" value="runbooks" style="edgeStyle=orthogonalEdgeStyle;html=1;endArrow=block;endFill=1;strokeColor=#4f7cff;" edge="1" parent="1" source="N_UI" target="N_TECHDOCS">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E5" value="POST /deploy" style="edgeStyle=orthogonalEdgeStyle;html=1;endArrow=block;endFill=1;strokeColor=#2f9e44;" edge="1" parent="1" source="N_SCAFFOLDER" target="N_ORCH">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E6" value="policy check" style="edgeStyle=orthogonalEdgeStyle;html=1;endArrow=block;endFill=1;strokeColor=#2f9e44;" edge="1" parent="1" source="N_ORCH" target="N_POLICY">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E7" value="authz" style="edgeStyle=orthogonalEdgeStyle;html=1;endArrow=block;endFill=1;strokeColor=#e8590c;" edge="1" parent="1" source="N_POLICY" target="N_IAM">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E8" value="approved â†’ adapters" style="edgeStyle=orthogonalEdgeStyle;html=1;endArrow=block;endFill=1;strokeColor=#2f9e44;" edge="1" parent="1" source="N_POLICY" target="N_ADAPTERS">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E9" value="trigger pipeline" style="edgeStyle=orthogonalEdgeStyle;html=1;endArrow=block;endFill=1;strokeColor=#e8590c;" edge="1" parent="1" source="N_ADAPTERS" target="N_CICD">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E10" value="deploy DEV (MVP)" style="edgeStyle=orthogonalEdgeStyle;html=1;endArrow=block;endFill=1;strokeColor=#c2255c;" edge="1" parent="1" source="N_CICD" target="N_DEV">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E11" value="deploy TEST (P2)" style="edgeStyle=orthogonalEdgeStyle;html=1;endArrow=block;endFill=1;strokeColor=#c2255c;dashed=1;" edge="1" parent="1" source="N_CICD" target="N_TEST">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E12" value="audit events" style="edgeStyle=orthogonalEdgeStyle;html=1;endArrow=block;endFill=1;strokeColor=#2f9e44;" edge="1" parent="1" source="N_ORCH" target="N_AUDIT">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E13" value="KPIs" style="edgeStyle=orthogonalEdgeStyle;html=1;endArrow=block;endFill=1;strokeColor=#e8590c;" edge="1" parent="1" source="N_AUDIT" target="N_METRICS">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <!-- Phase 2 edges -->
        <mxCell id="E14" value="build/push (P2)" style="edgeStyle=orthogonalEdgeStyle;html=1;endArrow=block;endFill=1;strokeColor=#e8590c;dashed=1;" edge="1" parent="1" source="N_CICD" target="N_REG">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E15" value="scan gates (P2)" style="edgeStyle=orthogonalEdgeStyle;html=1;endArrow=block;endFill=1;strokeColor=#e8590c;dashed=1;" edge="1" parent="1" source="N_CICD" target="N_SCANS">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <!-- Phase 3 edges -->
        <mxCell id="E16" value="runtime policy (P3)" style="edgeStyle=orthogonalEdgeStyle;html=1;endArrow=block;endFill=1;strokeColor=#c2255c;dotted=1;" edge="1" parent="1" source="N_DEV" target="N_RUNTIME_POLICY">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

        <mxCell id="E17" value="runtime policy (P3)" style="edgeStyle=orthogonalEdgeStyle;html=1;endArrow=block;endFill=1;strokeColor=#c2255c;dotted=1;" edge="1" parent="1" source="N_TEST" target="N_RUNTIME_POLICY">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>

      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
```

Wenn du willst, kann ich dir auch eine **Variante ohne Kubernetes** (neutral: â€œRuntime DEV/TESTâ€) liefern â€“ aber das oben passt super zum Cloud-Native/Microservices-Zielbild.

---

# 2) Template bauen: Backstage Scaffolder YAML fÃ¼r â€œDeploy / Promoteâ€ (Golden Path)

Das Template ist so gebaut, dass Backstage **nur UX** ist. Die Regeln liegen im **Orchestrator**, wie im Diagramm.

## Datei: `templates/golden-path-deploy/template.yaml`

```yaml
apiVersion: scaffolder.backstage.io/v1beta3
kind: Template
metadata:
  name: golden-path-deploy
  title: Golden Path - Deploy / Promote
  description: Self-Service Deployment via IDP Orchestrator mit Guardrails (RBAC, Env Rules, Required Checks).
  tags:
    - idp
    - golden-path
    - deploy
spec:
  owner: group:platform-team
  type: service

  parameters:
    - title: Select Service & Action
      required:
        - service
        - action
        - environment
        - refType
        - ref
      properties:
        service:
          title: Service (Catalog Component)
          type: string
          ui:field: EntityPicker
          ui:options:
            catalogFilter:
              kind: Component

        action:
          title: Action
          type: string
          enum: [deploy, promote]
          enumNames: ["Deploy (to DEV)", "Promote (to TEST)"]
          default: deploy

        environment:
          title: Target Environment
          type: string
          enum: [dev, test]
          enumNames: ["DEV", "TEST"]
          default: dev

        refType:
          title: Reference Type
          type: string
          enum: [branch, tag]
          enumNames: ["Branch", "Tag"]
          default: branch

        ref:
          title: Branch/Tag
          description: "Examples: branch=feature/refund-fix, tag=v1.3.2"
          type: string
          minLength: 2

        changeReason:
          title: Change Reason (for audit)
          type: string
          ui:widget: textarea
          ui:options:
            rows: 4

    - title: Optional Inputs (advanced)
      properties:
        dryRun:
          title: Dry-run only (no execution)
          type: boolean
          default: false

        ticketId:
          title: External reference (optional)
          description: "Optional: Link to an internal change/ticket ID for traceability."
          type: string

  steps:
    # 1) Pull service context & ownership from Catalog
    - id: fetchEntity
      name: Fetch service entity
      action: catalog:fetch
      input:
        entityRef: ${{ parameters.service }}

    # 2) Simple UX guardrail: prevent impossible combinations early
    - id: validateBasics
      name: Validate basic constraints
      action: roadiehq:utils:assert
      input:
        condition: ${{ !(parameters.action == 'deploy' && parameters.environment == 'test') }}
        message: "Deploy action targets DEV. Use Promote for TEST."

    - id: validatePromoteTarget
      name: Validate promote target
      action: roadiehq:utils:assert
      input:
        condition: ${{ !(parameters.action == 'promote' && parameters.environment == 'dev') }}
        message: "Promote action targets TEST."

    # 3) Call IDP Orchestrator (single entrypoint) â€“ it enforces RBAC + env rules + required checks
    - id: callOrchestrator
      name: Submit to IDP Orchestrator
      action: http:backstage:request
      input:
        method: POST
        path: /api/idp/orchestrator/change
        headers:
          content-type: application/json
        body:
          action: ${{ parameters.action }}           # deploy | promote
          environment: ${{ parameters.environment }} # dev | test
          refType: ${{ parameters.refType }}         # branch | tag
          ref: ${{ parameters.ref }}
          dryRun: ${{ parameters.dryRun }}
          changeReason: ${{ parameters.changeReason }}
          externalRef: ${{ parameters.ticketId }}
          # service context for ownership + policy decisions
          entityRef: ${{ parameters.service }}
          entity:
            name: ${{ steps.fetchEntity.output.entity.metadata.name }}
            owner: ${{ steps.fetchEntity.output.entity.spec.owner }}
            system: ${{ steps.fetchEntity.output.entity.spec.system }}
            annotations: ${{ steps.fetchEntity.output.entity.metadata.annotations }}

    # 4) Make output human-friendly
    - id: summarize
      name: Summarize result
      action: roadiehq:utils:log
      input:
        message: >
          Orchestrator result:
          status=${{ steps.callOrchestrator.output.body.status }},
          runUrl=${{ steps.callOrchestrator.output.body.runUrl }},
          auditId=${{ steps.callOrchestrator.output.body.auditId }}.

  output:
    text:
      - title: Result
        content: |
          **Status:** ${{ steps.callOrchestrator.output.body.status }}
          **Message:** ${{ steps.callOrchestrator.output.body.message }}
    links:
      - title: Pipeline Run / Deployment Run
        url: ${{ steps.callOrchestrator.output.body.runUrl }}
      - title: Audit Record
        url: ${{ steps.callOrchestrator.output.body.auditUrl }}
      - title: Service in Catalog
        url: ${{ steps.fetchEntity.output.entity.metadata.annotations['backstage.io/view-url'] }}
```

### Orchestrator Contract (minimal, passend zum Diagramm)

Euer Backend-Endpunkt (Orchestrator) sollte etwas in dieser Art zurÃ¼ckgeben:

```json
{
  "status": "accepted",
  "message": "Deploy triggered",
  "runUrl": "https://cicd.example/runs/12345",
  "auditId": "audit-2026-000123",
  "auditUrl": "https://audit.example/events/audit-2026-000123"
}
```

### Was ihr damit sofort demonstrieren kÃ¶nnt (MVP)

* **Self-Service**: Klick â†’ Pipeline lÃ¤uft
* **Guardrails**: Orchestrator kann Requests ablehnen (RBAC/env rules)
* **Audit/KPIs**: auditId + Events (fÃ¼r DX-Messung)
* **Roadmap sichtbar**: Promote/Test, Scan Gates, Runtime Policies sind sauber als Phase 2/3 vorbereitet

---

## Als nÃ¤chstes (damitâ€™s wirklich lÃ¤uft)

Sag mir einfach, womit ihr im Prototyp am ehesten starten wollt:

* **A)** CI/CD = *Azure DevOps*
* **B)** CI/CD = *GitLab*
* **C)** â€egalâ€œ â†’ ich gebe dir einen **neutralen Orchestrator** (der nur ein Webhook/Pipeline triggern muss)

Dann passe ich dir **die Orchestrator-API** und (falls gewÃ¼nscht) einen **kleinen Beispiel-Orchestrator (Node.js)** an, der RBAC/env rules simuliert und einen Pipeline-Run triggert.



========================================


## Ausgangslage: Zwei Zielbilder, ein Vergleichsrahmen

Sie beschreiben **zwei sauber unterscheidbare Zielbilder**, die in der Arbeit auseinandergehalten werden mÃ¼ssen:

1. **INFRA-ONLY Enablement (Projektumfang, â€IDP out of scopeâ€œ)**

   * Ergebnis ist **nicht** ein Developer Portal, sondern eine **plattformfÃ¤hige Infrastruktur**: IaC, IAM, Secrets, Observability, Policy-as-Code, Automationsworkflows, Multi-Tenancy/Quotas, saubere Tool-Integration, dokumentierte Einstiegspunkte.
   * Portal ist hier hÃ¶chstens **â€IDP-readyâ€œ AnschlussfÃ¤higkeit**: Die Plattform liefert standardisierte Capabilities und Schnittstellen, die spÃ¤ter Ã¼ber ein Portal konsumierbar wÃ¤ren.

2. **IDP-/DX-orientierte Masterarbeits-Initiative (Forschung + Self-Service-MVP)**

   * Ergebnis ist ein **IDP Self-Service MVP** inkl. Guardrails und eine **bewertete Integrationsstrategie**, plus Adoption/DX-Aspekte (Interviews, KPIs, Roadmap).

Damit ist der â€Wettbewerbâ€œ (Vergleich) klar: **Backstage vs. Port** sind nicht â€die Plattformâ€œ, sondern **Portal-/Control-Plane-Kandidaten**, die an Ihrem **Infra-Layer** (Goal 1) andocken und in Goal 2 als MVP-TrÃ¤ger dienen.

---

## Abgeleitete Anforderungen (explizit aus Ihren Zielen)

### A) Anforderungen aus INFRA-ONLY Enablement

* **SouverÃ¤nitÃ¤t / Betriebsmodell**: On-prem + Multi-Cloud + Netzwerk/IAM-Vorgaben â†’ Portal muss in restriktive Umgebungen passen oder entkoppelt betreibbar sein.
* **â€Interfaces to platform servicesâ€œ**: Portal darf keine Magie sein, sondern muss definierte **Workflows/Runbooks/IaC-Pipelines** triggern (Provisioning, Config, Hardening).
* **Guardrails sind nicht verhandelbar**: Policy-as-Code, IAM, Quotas, Workload Isolation â†’ Durchsetzung im Plattform-Layer, Portal nur als kontrollierte AuslÃ¶ser-/Katalogschicht.
* **Observability & Alerting-QualitÃ¤t**: Monitoring der AutomationsausfÃ¼hrung (Status/Failures/Performance) und Noise-Reduktion â†’ muss als standardisierter Bestandteil der â€Golden Pathsâ€œ/Actions modellierbar sein.
* **Dokumentation als Change-Pflicht**: Docs-as-Code und nachvollziehbare Updates als Teil von InfrastrukturÃ¤nderungen.

### B) Anforderungen aus der Masterarbeit (IDP Self-Service MVP)

* **Schneller MVP** (mind. ein Use Case), **messbar** (DX/KPIs/Interviews) und **vergleichbar** (Integrationsaufwand, Governance-Tiefe, UX-Konsistenz).
* **Guardrails + Self-Service**: Entwickler sollen innerhalb klarer Leitplanken deployen/provisionieren kÃ¶nnen.
* **Tool-Orchestrierung**: IDP muss Integrationen nicht ersetzen, sondern orchestrieren (CI/CD, IaC, Artifact/Artifactory, Observability, IAM/SSO, Secrets).

---

## 1 â€“ Backstage (OSS): Passung zu Ihren Zielen

### StÃ¤rken (fÃ¼r Ihr Setup konkret)

* **Zielbild fÃ¼r â€IDP-readyâ€œ Infrastruktur:** Backstage eignet sich hervorragend als *Portal-Schicht Ã¼ber einem starken Plattform-Layer*. Sie bauen IaC/Policies/IAM/Observability sauber â€“ Backstage wird spÃ¤ter der konsolidierte Einstiegspunkt (Catalog, Doku, Golden Paths).
* **Hohe Integrationsfreiheit:** Wenn Ihr Tool-Stack heterogen ist (inkl. Artifactory-Spezifika, On-prem Constraints, eigene Security-Kontrollen), ist Backstage als Framework am flexibelsten.
* **BetriebssouverÃ¤nitÃ¤t:** FÃ¼r On-prem/Regulatorik ist Self-Hosting oft der entscheidende Faktor.

### Risiken / Nachteile (die Sie wissenschaftlich benennen sollten)

* **Implementierungs- und Betriebsaufwand:** Backstage ist kein fertiges Produkt. â€Schneller MVPâ€œ ist mÃ¶glich, aber nur, wenn Sie Scope strikt halten (ein Use Case, wenige Integrationen, klare Template-Strategie).
* **Governance hÃ¤ngt von Ihrer Umsetzung ab:** Scorecards/Standards/Actions sind nicht automatisch â€fertigâ€œ. Sie mÃ¼ssen die Governance-Mechanik bewusst designen (Policy Enforcement bleibt ohnehin im Plattform-Layer).

**Kurzfazit Backstage:** Bestes Ziel-Portal, wenn Ihre Arbeit **SouverÃ¤nitÃ¤t, Compliance-Fit und langfristige AnschlussfÃ¤higkeit** priorisiert und Sie bereit sind, Engineering-KapazitÃ¤t in Portal-Betrieb/Erweiterung zu investieren.

---

## 2 â€“ Port: Passung zu Ihren Zielen

### StÃ¤rken (fÃ¼r Ihr Setup konkret)

* **Time-to-Value fÃ¼r Self-Service MVP:** Port ist stark, wenn Sie schnell einen MVP mit Actions/Workflows, RBAC und konsistenter UX zeigen und evaluieren wollen.
* **Gute Modellierung von Plattform-Assets:** Wenn Sie neben Services auch Infrastruktur-Objekte (Cluster/Namespaces/DBs/Policies/Alerts/Quotas) als â€first classâ€œ im Portal fÃ¼hren mÃ¶chten, ist Port dafÃ¼r sehr direkt nutzbar.
* **Orchestrierung statt Ersatz:** Port kann als AuslÃ¶ser-Schicht Ã¼ber Ihre bestehenden IaC/CI-Workflows funktionieren â€“ passend zu Ihrem Infra-Layer-Ansatz.

### Risiken / Nachteile (die Sie sauber begrÃ¼nden sollten)

* **Betriebs-/Compliance-Fit kann limitieren:** Wenn SaaS-Vorgaben mit Datenklassifikation, Netzwerkrestriktionen oder On-prem-Anforderungen kollidieren, entsteht ein strukturelles Risiko oder ein Architekturkompromiss.
* **Vendor-/Produktparadigma:** Die Gestaltungsfreiheit ist geringer als bei Backstage; Sie evaluieren damit stÃ¤rker â€ProduktfÃ¤higkeitâ€œ als â€Framework-Architekturâ€œ.

**Kurzfazit Port:** Bestes Portal, wenn Ihre Masterarbeit **einen schnellen, demonstrierbaren Self-Service MVP** mit Governance und konsistenter UX braucht und das Betriebsmodell organisatorisch zulÃ¤ssig ist.

---

## 3 â€“ Schlussfolgerung fÃ¼r **Ihre beiden Ziele** (professionell, â€beim Namen genanntâ€œ)

### FÃ¼r Zielbild 1 (INFRA-ONLY Enablement, IDP out of scope)

**Backstage ist der robustere Referenzanker**, weil es als selbst kontrollierbare Portal-Schicht *spÃ¤ter* auf Ihre â€Platform Engineering Capabilitiesâ€œ gesetzt werden kann, ohne Ihre Compliance- und Betriebsanforderungen zu kompromittieren. In diesem Zielbild ist die zentrale Aussage: **Der Plattform-Layer liefert die Wahrheit (IaC, IAM, Policy-Enforcement, Observability), das Portal liefert die Kuratierung.** Backstage unterstÃ¼tzt diese Trennung sehr gut.

### FÃ¼r Zielbild 2 (Masterarbeit: IDP Self-Service MVP + DX)

**Port ist der schnellere MVP-TrÃ¤ger**, weil Sie Actions/Workflows und Governance-Elemente typischerweise schneller produktiv demonstrieren und in Interviews/KPIs bewerten kÃ¶nnen. Das stÃ¤rkt die wissenschaftliche Auswertung (Time-to-Value, wahrgenommene Konsistenz, Bedienbarkeit, Prozessdurchlaufzeit).

### Wissenschaftlich saubere Positionierung (die Sie so in die Arbeit schreiben kÃ¶nnen)

* **Backstage** reprÃ¤sentiert den **souverÃ¤nen Framework-Ansatz** (maximale Anpassbarkeit, geeignet fÃ¼r regulierte/heterogene Umgebungen, hÃ¶herer Engineering-Aufwand).
* **Port** reprÃ¤sentiert den **produktisierten Control-Plane-Ansatz** (schnelle Operationalisierung von Self-Service-Prozessen, konsistente UX, potenzielle EinschrÃ¤nkungen durch Betriebsmodell und Vendor-Bindung).

---

## Praktische Empfehlung fÃ¼r Ihren Vergleich (konkret, minimal, prÃ¼fbar)

WÃ¤hlen Sie **denselben MVP-Use-Case** fÃ¼r beide Systeme, damit der Vergleich wissenschaftlich belastbar ist:

**Use Case (ein Beispiel, passend zu Ihren Zielen):**
â€Provisioniere eine neue Applikations-Umgebung (Namespace + Quota + Standard-Policies), lege Repo + CI-Pipeline an, binde Observability-Baseline (Dashboards/Alerts) an und erzwinge Policy-Checks â€“ inklusive AusfÃ¼hrungs-Monitoring und dokumentiertem Runbook.â€œ

Dann messen Sie pro Kandidat:

* Integrationsaufwand (Tage, Artefakte, KomplexitÃ¤t)
* Governance-Tiefe (RBAC, Approvals, Auditability; Enforcement weiterhin im Policy/IAM-Layer)
* Konsistenz der Schnittstellen fÃ¼r Teams (â€tool interfacesâ€œ)
* FÃ¤higkeit, Monitoring/Alerting-QualitÃ¤t als Standard zu verankern
* Dokumentation als verpflichtender Change-Output

Wenn Sie mir sagen, ob **SaaS im Unternehmen zulÃ¤ssig** ist (Ja/Nein), kann ich die Schlussfolgerung **auf eine eindeutige Empfehlung** zuspitzen (Backstage-only vs. Port-only vs. Dual-Evaluation als Studien-Design).


======================================

Klar â€“ wenn wir **Ihr Projekt strikt nach den gesetzten Zielen** bewerten (INFRA-ONLY Enablement â†’ Automation â†’ IDP-Ready, **IDP/Portal-Rollout ausdrÃ¼cklich out of scope**), dann fallen viele Kandidaten aus **sehr konkreten** GrÃ¼nden heraus: **Betriebsmodell/SouverÃ¤nitÃ¤t**, **Ã–kosystem-Bindung**, oder **falscher Schwerpunkt (DX/Scorecards statt Infra-APIs & Automationsschnittstellen)**.

## Warum die anderen (hÃ¤ufig) nicht passen â€“ bezogen auf Ihr Projekt

### 2 â€“ Roadie (Backstage-as-a-Service)

Roadie ist **hosted/managed** auf Backstage-Basis. ([Internal Developer Platform][1])
**Warum das fÃ¼r Ihr INFRA-ONLY-Zielbild oft nicht passt:** In einem Vorhaben mit **On-Prem + Multi-Cloud + strikten IAM/Netz/Compliance-Leitplanken** ist ein SaaS-Portal hÃ¤ufig organisatorisch oder technisch schwer durchsetzbar (DatenflÃ¼sse, IdentitÃ¤tskopplung, Netzsegmentierung, Regulatorik). Roadie reduziert zwar Betriebsaufwand, verschiebt aber die Kontrolle Richtung SaaS. ([Internal Developer Platform][1])

### 3 â€“ Spotify Portal for Backstage (Commercial)

Das Spotify-Portal ist eine **kommerziell kuratierte Backstage-Distribution** mit Bundle/Subscription und integrierten Plugins (z. B. Soundcheck). ([backstage.spotify.com][2])
**Warum oft nicht passend:** FÃ¼r Ihr Projekt zÃ¤hlt primÃ¤r **Infrastruktur-FÃ¤higkeit** (IaC/IAM/Policy/Observability/Automation) â€“ das Spotify-Portal optimiert vor allem die **Portal-Experience** (Standardisierung/Scorecards/UX) und ist dabei ein **kommerzieller Produktpfad**. Wenn â€IDP-Implementierungâ€œ out of scope ist, ist das in der Regel **zu portal-lastig** (und kommerziell gebunden). ([backstage.spotify.com][2])

### 4 â€“ Cortex

Cortex ist ein IDP mit **Cloud oder self-hosted (Helm)** und starker Ausrichtung auf **Service-Maturity/Standards** (System of Record, QualitÃ¤t/Readiness). ([Internal Developer Platform][3])
**Warum oft nicht passend:** FÃ¼r Ihr Zielbild steht **Infrastructure Enablement** im Vordergrund (Provisioning/Config-Automation, Multi-Tenancy/Quotas, Policy-Enforcement, Automation-Monitoring). Cortex ist zwar technisch solide, aber sein Kernwert liegt eher in **Service-Governance/Health/Readiness** als in â€Infra-APIs zuerstâ€œ. ([Cortex][4])

### 6 â€“ OpsLevel

OpsLevel positioniert sich als Developer Portal mit **Visibility + Standards/Maturity + Self-Service**, inkl. **Self-Hosted** (Kubernetes-basiert). ([opslevel.com][5])
**Warum oft nicht passend:** Es ist inhaltlich sehr stark bei **Standards/Scorecards** (â€Maturityâ€œ als Leitmotiv). FÃ¼r Ihr INFRA-ONLY-Programm (IDP out of scope) ist das hÃ¤ufig **nicht der Engpass**: Sie mÃ¼ssen zuerst **die Plattform-Kontrollen und Automations-Schnittstellen** liefern; Scorecards/Developer-Governance wÃ¤ren in Ihrer Abgrenzung eher â€spÃ¤terâ€œ. ([opslevel.com][6])

### 7 â€“ Harness IDP

Harness IDP ist eng im Harness-Ã–kosystem verankert; es gibt Dokumentation fÃ¼r Deployment in eine **Self Managed Platform (SMP)**. ([developer.harness.io][7])
**Warum oft nicht passend:** Der Fit ist am besten, wenn Harness bereits **zentraler Teil** Ihrer Delivery/Platform-Toolchain ist. Sonst fÃ¼hrt das zu **Ã–kosystem-Bindung** (Architektur wird â€Harness-firstâ€œ statt â€Infra-APIs-firstâ€œ). AuÃŸerdem ist SMP an konkrete Voraussetzungen geknÃ¼pft (z. B. IDP 2.0, bestimmte Clusterbedingungen). ([developer.harness.io][8])

### 8 â€“ Datadog Internal Developer Portal

Datadog IDP ist explizit **fully managed** und verbindet Portal mit **Live-Telemetry**; Kern sind **Catalog, Scorecards, Self-Service Actions**. ([Datadog Monitoring][9])
**Warum oft nicht passend:** Ihr Projekt verlangt Observability, aber auch **Tool-Konsolidierung, On-Prem/Multi-Cloud-SouverÃ¤nitÃ¤t und Compliance-Kontrolle**. Datadog IDP ist technisch attraktiv, bindet den Portal-Layer jedoch stark an **Datadog als zentrale Plattform** (Managed-Modell + Telemetry-Zentrierung). Das kann Ihrer Zielsetzung â€plattformfÃ¤hige, wiederverwendbare Infrastrukturbausteineâ€œ widersprechen, wenn Observability bewusst **vendor-neutral** oder on-prem-nah bleiben muss. ([Datadog Monitoring][9])

### 9 â€“ Atlassian Compass

Compass ist ein Atlassian-Produkt (Catalog/Scorecards) mit **klarer Cloud-Preisstruktur**. ([Atlassian][10])
**Warum oft nicht passend:** Compass ist stark als **Service Catalog/Health** im Atlassian-Kontext, aber fÃ¼r Ihr Projekt (IaC-DurchgÃ¤ngigkeit, Automations-Monitoring, Policy-as-Code Enforcement, Multi-Tenancy/Quotas) ist es typischerweise **zu katalog-zentriert** und **zu wenig** als Infra-Orchestrierungsfrontdoor gedacht â€“ insbesondere auÃŸerhalb eines â€Atlassian-firstâ€œ Tooling-Modells. ([Atlassian][10])

---

## Konsequenz fÃ¼r Ihren â€Wettbewerbâ€œ

FÃ¼r Ihr Projekt sind **Backstage (OSS)** und **Port** deshalb vorne, weil sie den benÃ¶tigten Architekturgrundsatz unterstÃ¼tzen:

* **Portal als Frontdoor**, **Execution & Guardrails im Plattform-Layer** (IaC, IAM, Policy-as-Code, Quotas, Automation-Workflows).
* Backstage maximiert **SouverÃ¤nitÃ¤t & Integrationsfreiheit** (self-hosted, framework-basiert).
* Port maximiert **Time-to-Value fÃ¼r Self-Service Actions/Workflows** und ein flexibles Modell fÃ¼r Plattform-Assets; Pricing/Free-Tier ist klar dokumentiert. ([port.io][11])

Wenn Sie wollen, kann ich das als **ultrakompakte Entscheidungslogik** (Ausschlusskriterien + â€best fitâ€œ-Score je Phase) formulieren â€“ 10â€“15 Zeilen, masterarbeitstauglich.

[1]: https://internaldeveloperplatform.org/developer-portals/roadie/?utm_source=chatgpt.com "Roadie"
[2]: https://backstage.spotify.com/discover/blog/silverflow-soundcheck-leaderboards/?utm_source=chatgpt.com "Building better code at Silverflow: Backstage, Soundcheck ..."
[3]: https://internaldeveloperplatform.org/developer-portals/cortex/?utm_source=chatgpt.com "Cortex"
[4]: https://www.cortex.io/post/what-is-an-internal-developer-portal?utm_source=chatgpt.com "Internal Developer Portal: Definition, Capabilities & Use ..."
[5]: https://www.opslevel.com/?utm_source=chatgpt.com "OpsLevel | Internal Developer Portal for High-Performing Teams"
[6]: https://www.opslevel.com/resources/the-complete-guide-to-internal-developer-portals?utm_source=chatgpt.com "The Complete Guide to Internal Developer Portals"
[7]: https://developer.harness.io/docs/internal-developer-portal?utm_source=chatgpt.com "Internal Developer Portal Documentation"
[8]: https://developer.harness.io/docs/internal-developer-portal/smp/idp-onboarding?utm_source=chatgpt.com "IDP Onboarding to SMP Environments [BETA]"
[9]: https://docs.datadoghq.com/internal_developer_portal/?utm_source=chatgpt.com "Internal Developer Portal"
[10]: https://www.atlassian.com/software/compass/pricing?utm_source=chatgpt.com "Compass - Pricing"
[11]: https://www.port.io/pricing?utm_source=chatgpt.com "Plans and Pricing"

=====================================
FÃ¼r das vorliegende Vorhaben (INFRA-ONLY Enablement in den Phasen Foundation â†’ Infrastructure Automation â†’ IDP-Ready) sind viele der genannten LÃ¶sungen nicht deshalb â€schlechtâ€œ, sondern weil ihr primÃ¤rer Wertbeitrag strukturell auÃŸerhalb der gesetzten Ziele liegt oder weil ihr Betriebs- und Ã–kosystemmodell typischerweise nicht mit den Randbedingungen eines stark governance- und compliance-getriebenen Infrastrukturprogramms harmoniert. Roadie reduziert zwar den operativen Aufwand durch ein vollstÃ¤ndig gemanagtes Backstage-Angebot, verschiebt damit jedoch Kontroll- und Integrationshoheit in ein SaaS-Betriebsmodell, was in Umgebungen mit On-Premise-Anteilen, strikter Netzwerksegmentierung, eng gekoppeltem IAM sowie regulatorischen Vorgaben hÃ¤ufig ein wesentliches Architektur- und Freigaberisiko darstellt. Das Spotify Portal for Backstage verfolgt ebenfalls einen kommerziellen, kuratierten Ansatz (â€Backstage in a boxâ€œ) und optimiert vor allem die portalbezogene Produkt-Experience; fÃ¼r ein Projekt, in dem die eigentliche Portalimplementierung ausdrÃ¼cklich nicht im Scope liegt, ist dieser Fokus regelmÃ¤ÃŸig zu portal-lastig, da die zentrale WertschÃ¶pfung hier in der technischen BefÃ¤higungsschicht (IaC, Policies, IAM/Secrets, Observability, Automationsschnittstellen) liegt und nicht in der schnellen Bereitstellung einer kuratierten UI. Cortex und OpsLevel sind in der Regel besonders stark in der DomÃ¤ne â€Service Governanceâ€œ (Service Catalog, Standards/Scorecards, Maturity, Initiatives) und eignen sich hervorragend, wenn Organisationssteuerung, Service-Health und StandardkonformitÃ¤t den dominierenden Engpass darstellen; im Kontext Ihres Programms ist der Engpass jedoch primÃ¤r die Herstellung belastbarer, automatisierbarer und erzwingbarer PlattformfÃ¤higkeiten (Provisioning, Konfigurationsautomation, Hardening, Multi-Tenancy/Quotas, Policy-as-Code Enforcement sowie Monitoring der AutomationsausfÃ¼hrung). Dadurch entsteht hÃ¤ufig eine Schwerpunktverschiebung weg von der Infrastruktur-BefÃ¤higung hin zur DX-/Governance-OberflÃ¤che, die in Ihrem Zeitplan explizit ausgeklammert ist. Harness IDP ist im Kern ein Ã–kosystem-Portal, dessen Nutzen besonders dann maximal ist, wenn Harness bereits die zentrale Delivery- und Plattformbasis bildet; ohne ein â€Harness-firstâ€œ-Setup fÃ¼hrt die EinfÃ¼hrung typischerweise zu strategischer Toolbindung und zu einer Architekturausrichtung, die weniger von Ihren definierten Infrastruktur-APIs und Guardrails, sondern stÃ¤rker von den Annahmen und Integrationspfaden des Herstellers bestimmt wird. Datadog Internal Developer Portal ist technisch attraktiv in Organisationen, die Observability und Telemetry ohnehin konsequent auf Datadog zentrieren; im Rahmen Ihres Vorhabens, das explizit Tool-Konsolidierung, Compliance-FÃ¤higkeit und SouverÃ¤nitÃ¤t (inkl. On-Prem/Multi-Cloud) adressiert, kann ein vollstÃ¤ndig gemanagter, observability-zentrierter Portalansatz jedoch eine unerwÃ¼nschte AbhÃ¤ngigkeit erzeugen und die vendor-neutrale Ausgestaltung der Infrastrukturbausteine und Schnittstellen erschweren. Atlassian Compass wiederum ist im Atlassian-Kontext ein starker Servicekatalog- und Health-Ansatz, bleibt jedoch typischerweise stÃ¤rker auf Katalogisierung und Scorecards fokussiert und ist damit fÃ¼r ein infra-zentriertes Enablementprogramm, dessen Kern in automatisierter Bereitstellung, konfigurationsgetriebener Standardisierung, Policy-as-Code Durchsetzung und kontrollierter Multi-Tenancy liegt, hÃ¤ufig nicht der naheliegendste PrimÃ¤rkandidat.

Aus diesem Ausschlussbild ergibt sich, warum Backstage (OSS) und Port im Wettbewerb fÃ¼r Ihr Projekt regelmÃ¤ÃŸig als die passendsten Kandidaten Ã¼brig bleiben: Beide unterstÃ¼tzen die zentrale Architekturmaxime Ihres Vorhabens, nÃ¤mlich die klare Trennung zwischen Portal-Interaktion und Plattform-Execution. Die â€hartenâ€œ Guardrails (Policy-as-Code, IAM, Quotas, Workload-Isolation, Compliance) verbleiben im Plattform-Layer und werden dort technisch erzwungen; das Portal fungiert als kuratierter Einstiegspunkt, der standardisierte Pfade sichtbar macht und kontrolliert auslÃ¶st. Backstage ist dafÃ¼r besonders geeignet, wenn Self-Hosting, Integrationsfreiheit und langfristige SouverÃ¤nitÃ¤t im Vordergrund stehen, weil es als Framework die passgenaue Abbildung Ihrer Toolchain, Netzwerk- und IAM-Topologie sowie Ihrer Governance-Mechanismen erlaubt â€“ bei akzeptiertem Engineering- und Betriebsaufwand. Port ist dagegen besonders geeignet, wenn eine schnelle, konsistente Operationalisierung von Self-Service-Prozessen Ã¼ber Actions/Workflows gefragt ist und das Betriebsmodell organisatorisch zulÃ¤ssig ist, weil es die Orchestrierung standardisierter, auditierbarer AblÃ¤ufe produktisiert und zugleich die Modellierung von Plattformassets als erstklassige EntitÃ¤ten unterstÃ¼tzt. Beide Optionen lassen sich damit stringent an Ihren Phasenplan anschlieÃŸen: Sie schaffen zunÃ¤chst die Infrastrukturcapabilities und Automationsschnittstellen (Foundation/Automation) und setzen anschlieÃŸend â€“ IDP-ready â€“ einen Portal-Layer auf, der diese FÃ¤higkeiten konsistent konsumierbar macht, ohne die Durchsetzung der Leitplanken aus der Plattformkontrollebene herauszulÃ¶sen.


==================================
# Crossplane

**Crossplane ist in der Regel *keine* IDP im engeren Sinne** (also kein â€Internal Developer Portalâ€œ mit Katalog-UI, Doku-Einstiegspunkt, Ownership-Ansichten, Self-Service-Formularen etc.). Es ist vielmehr ein **Kubernetes-natives Control-Plane-/Orchestrierungs-Framework**, mit dem Plattformteams **eigene, abstrahierte Infrastruktur-APIs** bereitstellen kÃ¶nnen â€“ ein typischer **Baustein unterhalb** einer IDP. ([docs.crossplane.io][1])

Wissenschaftlich prÃ¤zise formuliert: Crossplane verwandelt ein Kubernetes-Cluster in eine â€universal control planeâ€œ und ermÃ¶glicht es, Ã¼ber **Custom APIs** (Composite Resources, XRDs, Compositions) Infrastrukturressourcen deklarativ zu modellieren, zu provisionieren und zu reconciliieren. ([docs.crossplane.io][1]) Damit eignet sich Crossplane sehr gut als **Infrastructure-API Layer** fÃ¼r Self-Service â€“ also als Engine, die Port/Backstage-Workflows auslÃ¶sen oder konsumieren kÃ¶nnen. ([crossplane.io][2])

Kurz:

* **Crossplane = Platform/Control-Plane-Baustein (Infrastructure APIs, Guardrails hinter APIs, GitOps-fÃ¤hig).** ([crossplane.io][2])
* **Backstage/Port = IDP-Portal-Layer (Katalog, Doku-Frontdoor, Actions/Workflows als Self-Service UX).**

Wenn Sie es sauber in einem Satz brauchen: *Crossplane ist kein IDP-Portal, sondern ein Control-Plane-Framework, das hÃ¤ufig als infrastrukturelle Grundlage dient, um eine IDP (z. B. Backstage oder Port) mit standardisierten, sicheren Self-Service-Infrastruktur-APIs zu versorgen.* ([crossplane.io][2])

[1]: https://docs.crossplane.io/v1.20/?utm_source=chatgpt.com "Overview Â· Crossplane v1.20"
[2]: https://www.crossplane.io/?utm_source=chatgpt.com "Crossplane Is the Cloud-Native Framework for Platform ..."




Ja â€“ in IDP-Kontexten (Backstage/Port als **Portal-Layer**) tauchen darunter hÃ¤ufig **Control-Plane-/Orchestrierungs-Frameworks** auf, die **Infrastructure-APIs** und **Guardrails** bereitstellen. Hier ist eine praxisnahe Liste der gÃ¤ngigsten Alternativen zu Crossplane, gruppiert nach Einsatztyp:

### Kubernetes-native Infrastructure Control Planes (Cloud-Ressourcen als CRDs)

* **AWS Controllers for Kubernetes (ACK)** â€“ verwaltet AWS-Services direkt aus Kubernetes Ã¼ber Controller/CRDs (AWS-Ressourcen â€wie K8s-Objekteâ€œ). ([Amazon Web Services, Inc.][1])
* **Google Config Connector (KCC)** â€“ Kubernetes-Add-on/OSS zur Verwaltung von Google-Cloud-Ressourcen via Kubernetes-API und CRDs/Controller. ([Google Cloud Documentation][2])
* **Azure Service Operator (ASO)** â€“ provisioniert und betreibt Azure-Ressourcen aus Kubernetes heraus Ã¼ber CRDs (Kubernetes-primitives statt separate Toolchains). ([azure.github.io][3])

### Cluster Lifecycle / â€Kubernetes-as-a-Serviceâ€œ Control Planes (Multi-Cluster, On-Prem/Multi-Cloud)

* **Kubernetes Cluster API (CAPI)** â€“ deklarative APIs/Tooling zur Provisionierung, Upgrades und Operation mehrerer Kubernetes-Cluster (Cluster-Lifecycle als Kubernetes-API). ([cluster-api.sigs.k8s.io][4])
* **Gardener** â€“ automatisiertes Management von Kubernetes-Clustern â€as a serviceâ€œ mit extensiblem Framework, multi-cloud-fÃ¤hig und Kubernetes-native API. ([GitHub][5])

### Platform Orchestrators / Application Delivery Control Planes (Self-Service â€Capabilitiesâ€œ Ã¼ber hÃ¶here Abstraktionen)

* **Kratix** â€“ OSS-Plattform-Orchestrator, der â€Capabilitiesâ€œ als **governed APIs** (â€Promisesâ€œ) definiert und ausliefert; explizit fÃ¼r IDP-Aufbau gedacht. ([platformengineering.org][6])
* **KubeVela (OAM-basiert)** â€“ application-centric Delivery-System, das OAM nutzt und Kubernetes als Control Plane einsetzt; stellt hÃ¶here APIs fÃ¼r Deployment/Workflows bereit. ([kubevela.io][7])
* **Open Application Model (OAM) â€“ Spec** â€“ keine Implementierung, aber relevante Spezifikation fÃ¼r hÃ¶here, portable App-Abstraktionen, die viele Plattformen/Tools (z. B. KubeVela) nutzen. ([oam.dev][8])

### IaC-Execution â€aus Kubernetes herausâ€œ (Terraform/OpenTofu/Pulumi als kontrollierte Reconciler)

* **HCP Terraform Operator for Kubernetes** â€“ verwaltet Terraform-Workspaces/Agentpools/Module Ã¼ber Kubernetes-Controller und CRDs (Terraform-Runs Ã¼ber K8s-API). ([HashiCorp Developer][9])
* **Flux IaC / Tofu Controller (ehem. Weave TF-Controller)** â€“ GitOps-Controller, der OpenTofu/Terraform Ressourcen im Flux-Modell reconciled (IaC â€GitOps-ifiedâ€œ). ([GitHub][10])
* **Pulumi Kubernetes Operator** â€“ erstellt/aktualisiert Pulumi Stacks als Kubernetes-Ressourcen; GitOps-Workflows fÃ¼r Cloud-Infra Ã¼ber Kubernetes. ([GitHub][11])

### Multi-Tenancy / â€Control plane per teamâ€œ (oft als Enabler fÃ¼r Plattform-Isolierung)

* **vCluster** â€“ virtuelle Kubernetes-Cluster in Namespaces; jeder vCluster hat eigenen API-Server und unterstÃ¼tzt flexible Tenancy/Isolation. ([GitHub][12])

Wenn du willst, ordne ich diese Liste in **eure drei Projektphasen** ein (Foundation / Automation / IDP-Ready) und gebe pro Phase 2â€“3 â€realistische Kombinationsmusterâ€œ (z. B. *CAPI/Gardener + Crossplane/ACK + Backstage/Port*), inkl. kurzer ArchitekturbegrÃ¼ndung.

[1]: https://aws.amazon.com/blogs/containers/aws-controllers-for-kubernetes-ack/?utm_source=chatgpt.com "Introducing the AWS Controllers for Kubernetes (ACK)"
[2]: https://docs.cloud.google.com/config-connector/docs/overview?utm_source=chatgpt.com "Config Connector overview - Google Cloud Documentation"
[3]: https://azure.github.io/azure-service-operator/?utm_source=chatgpt.com "Azure Service Operator v2"
[4]: https://cluster-api.sigs.k8s.io/?utm_source=chatgpt.com "Kubernetes Cluster API"
[5]: https://github.com/gardener/gardener?utm_source=chatgpt.com "gardener/gardener: Homogeneous Kubernetes clusters at ..."
[6]: https://platformengineering.org/tools/kratix?utm_source=chatgpt.com "Kratix - Platform tooling"
[7]: https://kubevela.io/docs/?utm_source=chatgpt.com "Introduction"
[8]: https://oam.dev/?utm_source=chatgpt.com "OAM | Open Application Model Specification"
[9]: https://developer.hashicorp.com/terraform/cloud-docs/integrations/kubernetes?utm_source=chatgpt.com "HCP Terraform Operator for Kubernetes overview"
[10]: https://github.com/flux-iac/tofu-controller?utm_source=chatgpt.com "flux-iac/tofu-controller: A GitOps OpenTofu and Terraform ..."
[11]: https://github.com/pulumi/pulumi-kubernetes-operator?utm_source=chatgpt.com "pulumi/pulumi-kubernetes-operator - GitHub"
[12]: https://github.com/loft-sh/vcluster?utm_source=chatgpt.com "vCluster - Create fully functional virtual Kubernetes clusters"

